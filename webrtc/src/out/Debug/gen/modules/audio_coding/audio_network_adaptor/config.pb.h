// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_config_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_config_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_config_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_config_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace webrtc {
namespace audio_network_adaptor {
namespace config {
class BitrateController;
class BitrateControllerDefaultTypeInternal;
extern BitrateControllerDefaultTypeInternal _BitrateController_default_instance_;
class ChannelController;
class ChannelControllerDefaultTypeInternal;
extern ChannelControllerDefaultTypeInternal _ChannelController_default_instance_;
class Controller;
class ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
class ControllerManager;
class ControllerManagerDefaultTypeInternal;
extern ControllerManagerDefaultTypeInternal _ControllerManager_default_instance_;
class Controller_ScoringPoint;
class Controller_ScoringPointDefaultTypeInternal;
extern Controller_ScoringPointDefaultTypeInternal _Controller_ScoringPoint_default_instance_;
class DtxController;
class DtxControllerDefaultTypeInternal;
extern DtxControllerDefaultTypeInternal _DtxController_default_instance_;
class FecController;
class FecControllerDefaultTypeInternal;
extern FecControllerDefaultTypeInternal _FecController_default_instance_;
class FecControllerRplrBased;
class FecControllerRplrBasedDefaultTypeInternal;
extern FecControllerRplrBasedDefaultTypeInternal _FecControllerRplrBased_default_instance_;
class FecControllerRplrBased_Threshold;
class FecControllerRplrBased_ThresholdDefaultTypeInternal;
extern FecControllerRplrBased_ThresholdDefaultTypeInternal _FecControllerRplrBased_Threshold_default_instance_;
class FecController_Threshold;
class FecController_ThresholdDefaultTypeInternal;
extern FecController_ThresholdDefaultTypeInternal _FecController_Threshold_default_instance_;
class FrameLengthController;
class FrameLengthControllerDefaultTypeInternal;
extern FrameLengthControllerDefaultTypeInternal _FrameLengthController_default_instance_;
}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc
PROTOBUF_NAMESPACE_OPEN
template<> ::webrtc::audio_network_adaptor::config::BitrateController* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::BitrateController>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::ChannelController* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::ChannelController>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::Controller* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::Controller>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::ControllerManager* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::ControllerManager>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::DtxController* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::DtxController>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::FecController* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::FecController_Threshold* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController_Threshold>(Arena*);
template<> ::webrtc::audio_network_adaptor::config::FrameLengthController* Arena::CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FrameLengthController>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace webrtc {
namespace audio_network_adaptor {
namespace config {

// ===================================================================

class FecController_Threshold :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController.Threshold) */ {
 public:
  FecController_Threshold();
  virtual ~FecController_Threshold();

  FecController_Threshold(const FecController_Threshold& from);
  FecController_Threshold(FecController_Threshold&& from) noexcept
    : FecController_Threshold() {
    *this = ::std::move(from);
  }

  inline FecController_Threshold& operator=(const FecController_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController_Threshold& operator=(FecController_Threshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FecController_Threshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FecController_Threshold* internal_default_instance() {
    return reinterpret_cast<const FecController_Threshold*>(
               &_FecController_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FecController_Threshold& a, FecController_Threshold& b) {
    a.Swap(&b);
  }
  inline void Swap(FecController_Threshold* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FecController_Threshold* New() const final {
    return CreateMaybeMessage<FecController_Threshold>(nullptr);
  }

  FecController_Threshold* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FecController_Threshold>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FecController_Threshold& from);
  void MergeFrom(const FecController_Threshold& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FecController_Threshold* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecController.Threshold";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthPacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthPacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float low_bandwidth_packet_loss = 2;
  bool has_low_bandwidth_packet_loss() const;
  void clear_low_bandwidth_packet_loss();
  float low_bandwidth_packet_loss() const;
  void set_low_bandwidth_packet_loss(float value);

  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float high_bandwidth_packet_loss = 4;
  bool has_high_bandwidth_packet_loss() const;
  void clear_high_bandwidth_packet_loss();
  float high_bandwidth_packet_loss() const;
  void set_high_bandwidth_packet_loss(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController.Threshold)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 low_bandwidth_bps_;
  float low_bandwidth_packet_loss_;
  ::PROTOBUF_NAMESPACE_ID::int32 high_bandwidth_bps_;
  float high_bandwidth_packet_loss_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class FecController :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController) */ {
 public:
  FecController();
  virtual ~FecController();

  FecController(const FecController& from);
  FecController(FecController&& from) noexcept
    : FecController() {
    *this = ::std::move(from);
  }

  inline FecController& operator=(const FecController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController& operator=(FecController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FecController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FecController* internal_default_instance() {
    return reinterpret_cast<const FecController*>(
               &_FecController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FecController& a, FecController& b) {
    a.Swap(&b);
  }
  inline void Swap(FecController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FecController* New() const final {
    return CreateMaybeMessage<FecController>(nullptr);
  }

  FecController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FecController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FecController& from);
  void MergeFrom(const FecController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FecController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FecController_Threshold Threshold;

  // accessors -------------------------------------------------------

  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
    kTimeConstantMsFieldNumber = 3,
  };
  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold();
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_enabling_threshold);

  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold();
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_disabling_threshold);

  // optional int32 time_constant_ms = 3;
  bool has_time_constant_ms() const;
  void clear_time_constant_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 time_constant_ms() const;
  void set_time_constant_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_enabling_threshold_;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_disabling_threshold_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_constant_ms_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class FecControllerRplrBased_Threshold :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold) */ {
 public:
  FecControllerRplrBased_Threshold();
  virtual ~FecControllerRplrBased_Threshold();

  FecControllerRplrBased_Threshold(const FecControllerRplrBased_Threshold& from);
  FecControllerRplrBased_Threshold(FecControllerRplrBased_Threshold&& from) noexcept
    : FecControllerRplrBased_Threshold() {
    *this = ::std::move(from);
  }

  inline FecControllerRplrBased_Threshold& operator=(const FecControllerRplrBased_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased_Threshold& operator=(FecControllerRplrBased_Threshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FecControllerRplrBased_Threshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FecControllerRplrBased_Threshold* internal_default_instance() {
    return reinterpret_cast<const FecControllerRplrBased_Threshold*>(
               &_FecControllerRplrBased_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FecControllerRplrBased_Threshold& a, FecControllerRplrBased_Threshold& b) {
    a.Swap(&b);
  }
  inline void Swap(FecControllerRplrBased_Threshold* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FecControllerRplrBased_Threshold* New() const final {
    return CreateMaybeMessage<FecControllerRplrBased_Threshold>(nullptr);
  }

  FecControllerRplrBased_Threshold* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FecControllerRplrBased_Threshold>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FecControllerRplrBased_Threshold& from);
  void MergeFrom(const FecControllerRplrBased_Threshold& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FecControllerRplrBased_Threshold* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthRecoverablePacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthRecoverablePacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float low_bandwidth_recoverable_packet_loss = 2;
  bool has_low_bandwidth_recoverable_packet_loss() const;
  void clear_low_bandwidth_recoverable_packet_loss();
  float low_bandwidth_recoverable_packet_loss() const;
  void set_low_bandwidth_recoverable_packet_loss(float value);

  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float high_bandwidth_recoverable_packet_loss = 4;
  bool has_high_bandwidth_recoverable_packet_loss() const;
  void clear_high_bandwidth_recoverable_packet_loss();
  float high_bandwidth_recoverable_packet_loss() const;
  void set_high_bandwidth_recoverable_packet_loss(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 low_bandwidth_bps_;
  float low_bandwidth_recoverable_packet_loss_;
  ::PROTOBUF_NAMESPACE_ID::int32 high_bandwidth_bps_;
  float high_bandwidth_recoverable_packet_loss_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class FecControllerRplrBased :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased) */ {
 public:
  FecControllerRplrBased();
  virtual ~FecControllerRplrBased();

  FecControllerRplrBased(const FecControllerRplrBased& from);
  FecControllerRplrBased(FecControllerRplrBased&& from) noexcept
    : FecControllerRplrBased() {
    *this = ::std::move(from);
  }

  inline FecControllerRplrBased& operator=(const FecControllerRplrBased& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased& operator=(FecControllerRplrBased&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FecControllerRplrBased& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FecControllerRplrBased* internal_default_instance() {
    return reinterpret_cast<const FecControllerRplrBased*>(
               &_FecControllerRplrBased_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FecControllerRplrBased& a, FecControllerRplrBased& b) {
    a.Swap(&b);
  }
  inline void Swap(FecControllerRplrBased* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FecControllerRplrBased* New() const final {
    return CreateMaybeMessage<FecControllerRplrBased>(nullptr);
  }

  FecControllerRplrBased* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FecControllerRplrBased>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FecControllerRplrBased& from);
  void MergeFrom(const FecControllerRplrBased& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FecControllerRplrBased* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecControllerRplrBased";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FecControllerRplrBased_Threshold Threshold;

  // accessors -------------------------------------------------------

  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
  };
  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold();
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_enabling_threshold);

  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold();
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_disabling_threshold);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_enabling_threshold_;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_disabling_threshold_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class FrameLengthController :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FrameLengthController) */ {
 public:
  FrameLengthController();
  virtual ~FrameLengthController();

  FrameLengthController(const FrameLengthController& from);
  FrameLengthController(FrameLengthController&& from) noexcept
    : FrameLengthController() {
    *this = ::std::move(from);
  }

  inline FrameLengthController& operator=(const FrameLengthController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameLengthController& operator=(FrameLengthController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FrameLengthController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameLengthController* internal_default_instance() {
    return reinterpret_cast<const FrameLengthController*>(
               &_FrameLengthController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FrameLengthController& a, FrameLengthController& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameLengthController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameLengthController* New() const final {
    return CreateMaybeMessage<FrameLengthController>(nullptr);
  }

  FrameLengthController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameLengthController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FrameLengthController& from);
  void MergeFrom(const FrameLengthController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FrameLengthController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FrameLengthController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlIncreasingPacketLossFractionFieldNumber = 1,
    kFlDecreasingPacketLossFractionFieldNumber = 2,
    kFl20MsTo60MsBandwidthBpsFieldNumber = 3,
    kFl60MsTo20MsBandwidthBpsFieldNumber = 4,
    kFl60MsTo120MsBandwidthBpsFieldNumber = 5,
    kFl120MsTo60MsBandwidthBpsFieldNumber = 6,
    kFlIncreaseOverheadOffsetFieldNumber = 7,
    kFlDecreaseOverheadOffsetFieldNumber = 8,
    kFl20MsTo40MsBandwidthBpsFieldNumber = 9,
    kFl40MsTo20MsBandwidthBpsFieldNumber = 10,
    kFl40MsTo60MsBandwidthBpsFieldNumber = 11,
    kFl60MsTo40MsBandwidthBpsFieldNumber = 12,
  };
  // optional float fl_increasing_packet_loss_fraction = 1;
  bool has_fl_increasing_packet_loss_fraction() const;
  void clear_fl_increasing_packet_loss_fraction();
  float fl_increasing_packet_loss_fraction() const;
  void set_fl_increasing_packet_loss_fraction(float value);

  // optional float fl_decreasing_packet_loss_fraction = 2;
  bool has_fl_decreasing_packet_loss_fraction() const;
  void clear_fl_decreasing_packet_loss_fraction();
  float fl_decreasing_packet_loss_fraction() const;
  void set_fl_decreasing_packet_loss_fraction(float value);

  // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
  bool has_fl_20ms_to_60ms_bandwidth_bps() const;
  void clear_fl_20ms_to_60ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_20ms_to_60ms_bandwidth_bps() const;
  void set_fl_20ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
  bool has_fl_60ms_to_20ms_bandwidth_bps() const;
  void clear_fl_60ms_to_20ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_20ms_bandwidth_bps() const;
  void set_fl_60ms_to_20ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
  bool has_fl_60ms_to_120ms_bandwidth_bps() const;
  void clear_fl_60ms_to_120ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_120ms_bandwidth_bps() const;
  void set_fl_60ms_to_120ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
  bool has_fl_120ms_to_60ms_bandwidth_bps() const;
  void clear_fl_120ms_to_60ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_120ms_to_60ms_bandwidth_bps() const;
  void set_fl_120ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_increase_overhead_offset = 7;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_decrease_overhead_offset = 8;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
  bool has_fl_20ms_to_40ms_bandwidth_bps() const;
  void clear_fl_20ms_to_40ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_20ms_to_40ms_bandwidth_bps() const;
  void set_fl_20ms_to_40ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
  bool has_fl_40ms_to_20ms_bandwidth_bps() const;
  void clear_fl_40ms_to_20ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_40ms_to_20ms_bandwidth_bps() const;
  void set_fl_40ms_to_20ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
  bool has_fl_40ms_to_60ms_bandwidth_bps() const;
  void clear_fl_40ms_to_60ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_40ms_to_60ms_bandwidth_bps() const;
  void set_fl_40ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
  bool has_fl_60ms_to_40ms_bandwidth_bps() const;
  void clear_fl_60ms_to_40ms_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_40ms_bandwidth_bps() const;
  void set_fl_60ms_to_40ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FrameLengthController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float fl_increasing_packet_loss_fraction_;
  float fl_decreasing_packet_loss_fraction_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_20ms_to_60ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_20ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_120ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_120ms_to_60ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_increase_overhead_offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_decrease_overhead_offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_20ms_to_40ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_40ms_to_20ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_40ms_to_60ms_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_60ms_to_40ms_bandwidth_bps_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class ChannelController :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ChannelController) */ {
 public:
  ChannelController();
  virtual ~ChannelController();

  ChannelController(const ChannelController& from);
  ChannelController(ChannelController&& from) noexcept
    : ChannelController() {
    *this = ::std::move(from);
  }

  inline ChannelController& operator=(const ChannelController& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelController& operator=(ChannelController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChannelController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelController* internal_default_instance() {
    return reinterpret_cast<const ChannelController*>(
               &_ChannelController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChannelController& a, ChannelController& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelController* New() const final {
    return CreateMaybeMessage<ChannelController>(nullptr);
  }

  ChannelController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ChannelController& from);
  void MergeFrom(const ChannelController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChannelController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.ChannelController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannel1To2BandwidthBpsFieldNumber = 1,
    kChannel2To1BandwidthBpsFieldNumber = 2,
  };
  // optional int32 channel_1_to_2_bandwidth_bps = 1;
  bool has_channel_1_to_2_bandwidth_bps() const;
  void clear_channel_1_to_2_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 channel_1_to_2_bandwidth_bps() const;
  void set_channel_1_to_2_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 channel_2_to_1_bandwidth_bps = 2;
  bool has_channel_2_to_1_bandwidth_bps() const;
  void clear_channel_2_to_1_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 channel_2_to_1_bandwidth_bps() const;
  void set_channel_2_to_1_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ChannelController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 channel_1_to_2_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 channel_2_to_1_bandwidth_bps_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class DtxController :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.DtxController) */ {
 public:
  DtxController();
  virtual ~DtxController();

  DtxController(const DtxController& from);
  DtxController(DtxController&& from) noexcept
    : DtxController() {
    *this = ::std::move(from);
  }

  inline DtxController& operator=(const DtxController& from) {
    CopyFrom(from);
    return *this;
  }
  inline DtxController& operator=(DtxController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DtxController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DtxController* internal_default_instance() {
    return reinterpret_cast<const DtxController*>(
               &_DtxController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DtxController& a, DtxController& b) {
    a.Swap(&b);
  }
  inline void Swap(DtxController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DtxController* New() const final {
    return CreateMaybeMessage<DtxController>(nullptr);
  }

  DtxController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DtxController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DtxController& from);
  void MergeFrom(const DtxController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DtxController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.DtxController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDtxEnablingBandwidthBpsFieldNumber = 1,
    kDtxDisablingBandwidthBpsFieldNumber = 2,
  };
  // optional int32 dtx_enabling_bandwidth_bps = 1;
  bool has_dtx_enabling_bandwidth_bps() const;
  void clear_dtx_enabling_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 dtx_enabling_bandwidth_bps() const;
  void set_dtx_enabling_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 dtx_disabling_bandwidth_bps = 2;
  bool has_dtx_disabling_bandwidth_bps() const;
  void clear_dtx_disabling_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 dtx_disabling_bandwidth_bps() const;
  void set_dtx_disabling_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.DtxController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 dtx_enabling_bandwidth_bps_;
  ::PROTOBUF_NAMESPACE_ID::int32 dtx_disabling_bandwidth_bps_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class BitrateController :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.BitrateController) */ {
 public:
  BitrateController();
  virtual ~BitrateController();

  BitrateController(const BitrateController& from);
  BitrateController(BitrateController&& from) noexcept
    : BitrateController() {
    *this = ::std::move(from);
  }

  inline BitrateController& operator=(const BitrateController& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitrateController& operator=(BitrateController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BitrateController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitrateController* internal_default_instance() {
    return reinterpret_cast<const BitrateController*>(
               &_BitrateController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BitrateController& a, BitrateController& b) {
    a.Swap(&b);
  }
  inline void Swap(BitrateController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitrateController* New() const final {
    return CreateMaybeMessage<BitrateController>(nullptr);
  }

  BitrateController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitrateController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BitrateController& from);
  void MergeFrom(const BitrateController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BitrateController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.BitrateController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlIncreaseOverheadOffsetFieldNumber = 1,
    kFlDecreaseOverheadOffsetFieldNumber = 2,
  };
  // optional int32 fl_increase_overhead_offset = 1;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 fl_decrease_overhead_offset = 2;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.BitrateController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_increase_overhead_offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 fl_decrease_overhead_offset_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class Controller_ScoringPoint :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller.ScoringPoint) */ {
 public:
  Controller_ScoringPoint();
  virtual ~Controller_ScoringPoint();

  Controller_ScoringPoint(const Controller_ScoringPoint& from);
  Controller_ScoringPoint(Controller_ScoringPoint&& from) noexcept
    : Controller_ScoringPoint() {
    *this = ::std::move(from);
  }

  inline Controller_ScoringPoint& operator=(const Controller_ScoringPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller_ScoringPoint& operator=(Controller_ScoringPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Controller_ScoringPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Controller_ScoringPoint* internal_default_instance() {
    return reinterpret_cast<const Controller_ScoringPoint*>(
               &_Controller_ScoringPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Controller_ScoringPoint& a, Controller_ScoringPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller_ScoringPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Controller_ScoringPoint* New() const final {
    return CreateMaybeMessage<Controller_ScoringPoint>(nullptr);
  }

  Controller_ScoringPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Controller_ScoringPoint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Controller_ScoringPoint& from);
  void MergeFrom(const Controller_ScoringPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Controller_ScoringPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.Controller.ScoringPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUplinkBandwidthBpsFieldNumber = 1,
    kUplinkPacketLossFractionFieldNumber = 2,
  };
  // optional int32 uplink_bandwidth_bps = 1;
  bool has_uplink_bandwidth_bps() const;
  void clear_uplink_bandwidth_bps();
  ::PROTOBUF_NAMESPACE_ID::int32 uplink_bandwidth_bps() const;
  void set_uplink_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float uplink_packet_loss_fraction = 2;
  bool has_uplink_packet_loss_fraction() const;
  void clear_uplink_packet_loss_fraction();
  float uplink_packet_loss_fraction() const;
  void set_uplink_packet_loss_fraction(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 uplink_bandwidth_bps_;
  float uplink_packet_loss_fraction_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class Controller :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller) */ {
 public:
  Controller();
  virtual ~Controller();

  Controller(const Controller& from);
  Controller(Controller&& from) noexcept
    : Controller() {
    *this = ::std::move(from);
  }

  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller& operator=(Controller&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Controller& default_instance();

  enum ControllerCase {
    kFecController = 21,
    kFrameLengthController = 22,
    kChannelController = 23,
    kDtxController = 24,
    kBitrateController = 25,
    kFecControllerRplrBased = 26,
    CONTROLLER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Controller* internal_default_instance() {
    return reinterpret_cast<const Controller*>(
               &_Controller_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Controller& a, Controller& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Controller* New() const final {
    return CreateMaybeMessage<Controller>(nullptr);
  }

  Controller* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Controller>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Controller& from);
  void MergeFrom(const Controller& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Controller* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.Controller";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Controller_ScoringPoint ScoringPoint;

  // accessors -------------------------------------------------------

  enum : int {
    kScoringPointFieldNumber = 1,
    kFecControllerFieldNumber = 21,
    kFrameLengthControllerFieldNumber = 22,
    kChannelControllerFieldNumber = 23,
    kDtxControllerFieldNumber = 24,
    kBitrateControllerFieldNumber = 25,
    kFecControllerRplrBasedFieldNumber = 26,
  };
  // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
  bool has_scoring_point() const;
  void clear_scoring_point();
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& scoring_point() const;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* release_scoring_point();
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* mutable_scoring_point();
  void set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* scoring_point);

  // optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
  bool has_fec_controller() const;
  void clear_fec_controller();
  const ::webrtc::audio_network_adaptor::config::FecController& fec_controller() const;
  ::webrtc::audio_network_adaptor::config::FecController* release_fec_controller();
  ::webrtc::audio_network_adaptor::config::FecController* mutable_fec_controller();
  void set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* fec_controller);

  // optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
  bool has_frame_length_controller() const;
  void clear_frame_length_controller();
  const ::webrtc::audio_network_adaptor::config::FrameLengthController& frame_length_controller() const;
  ::webrtc::audio_network_adaptor::config::FrameLengthController* release_frame_length_controller();
  ::webrtc::audio_network_adaptor::config::FrameLengthController* mutable_frame_length_controller();
  void set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* frame_length_controller);

  // optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
  bool has_channel_controller() const;
  void clear_channel_controller();
  const ::webrtc::audio_network_adaptor::config::ChannelController& channel_controller() const;
  ::webrtc::audio_network_adaptor::config::ChannelController* release_channel_controller();
  ::webrtc::audio_network_adaptor::config::ChannelController* mutable_channel_controller();
  void set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* channel_controller);

  // optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
  bool has_dtx_controller() const;
  void clear_dtx_controller();
  const ::webrtc::audio_network_adaptor::config::DtxController& dtx_controller() const;
  ::webrtc::audio_network_adaptor::config::DtxController* release_dtx_controller();
  ::webrtc::audio_network_adaptor::config::DtxController* mutable_dtx_controller();
  void set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* dtx_controller);

  // optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
  bool has_bitrate_controller() const;
  void clear_bitrate_controller();
  const ::webrtc::audio_network_adaptor::config::BitrateController& bitrate_controller() const;
  ::webrtc::audio_network_adaptor::config::BitrateController* release_bitrate_controller();
  ::webrtc::audio_network_adaptor::config::BitrateController* mutable_bitrate_controller();
  void set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* bitrate_controller);

  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
  bool has_fec_controller_rplr_based() const;
  void clear_fec_controller_rplr_based();
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& fec_controller_rplr_based() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* release_fec_controller_rplr_based();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* mutable_fec_controller_rplr_based();
  void set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* fec_controller_rplr_based);

  void clear_controller();
  ControllerCase controller_case() const;
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller)
 private:
  class _Internal;
  void set_has_fec_controller();
  void set_has_frame_length_controller();
  void set_has_channel_controller();
  void set_has_dtx_controller();
  void set_has_bitrate_controller();
  void set_has_fec_controller_rplr_based();

  inline bool has_controller() const;
  inline void clear_has_controller();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* scoring_point_;
  union ControllerUnion {
    ControllerUnion() {}
    ::webrtc::audio_network_adaptor::config::FecController* fec_controller_;
    ::webrtc::audio_network_adaptor::config::FrameLengthController* frame_length_controller_;
    ::webrtc::audio_network_adaptor::config::ChannelController* channel_controller_;
    ::webrtc::audio_network_adaptor::config::DtxController* dtx_controller_;
    ::webrtc::audio_network_adaptor::config::BitrateController* bitrate_controller_;
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* fec_controller_rplr_based_;
  } controller_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class ControllerManager :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ControllerManager) */ {
 public:
  ControllerManager();
  virtual ~ControllerManager();

  ControllerManager(const ControllerManager& from);
  ControllerManager(ControllerManager&& from) noexcept
    : ControllerManager() {
    *this = ::std::move(from);
  }

  inline ControllerManager& operator=(const ControllerManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerManager& operator=(ControllerManager&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ControllerManager& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerManager* internal_default_instance() {
    return reinterpret_cast<const ControllerManager*>(
               &_ControllerManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ControllerManager& a, ControllerManager& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerManager* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerManager* New() const final {
    return CreateMaybeMessage<ControllerManager>(nullptr);
  }

  ControllerManager* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerManager>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ControllerManager& from);
  void MergeFrom(const ControllerManager& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ControllerManager* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audio_network_adaptor.config.ControllerManager";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllersFieldNumber = 1,
    kMinReorderingTimeMsFieldNumber = 2,
    kMinReorderingSquaredDistanceFieldNumber = 3,
  };
  // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
  int controllers_size() const;
  void clear_controllers();
  ::webrtc::audio_network_adaptor::config::Controller* mutable_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >*
      mutable_controllers();
  const ::webrtc::audio_network_adaptor::config::Controller& controllers(int index) const;
  ::webrtc::audio_network_adaptor::config::Controller* add_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >&
      controllers() const;

  // optional int32 min_reordering_time_ms = 2;
  bool has_min_reordering_time_ms() const;
  void clear_min_reordering_time_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 min_reordering_time_ms() const;
  void set_min_reordering_time_ms(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float min_reordering_squared_distance = 3;
  bool has_min_reordering_squared_distance() const;
  void clear_min_reordering_squared_distance();
  float min_reordering_squared_distance() const;
  void set_min_reordering_squared_distance(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ControllerManager)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller > controllers_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_reordering_time_ms_;
  float min_reordering_squared_distance_;
  friend struct ::TableStruct_config_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FecController_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecController_Threshold::has_low_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FecController_Threshold::clear_low_bandwidth_bps() {
  low_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FecController_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
  return low_bandwidth_bps_;
}
inline void FecController_Threshold::set_low_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  low_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
}

// optional float low_bandwidth_packet_loss = 2;
inline bool FecController_Threshold::has_low_bandwidth_packet_loss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FecController_Threshold::clear_low_bandwidth_packet_loss() {
  low_bandwidth_packet_loss_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float FecController_Threshold::low_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
  return low_bandwidth_packet_loss_;
}
inline void FecController_Threshold::set_low_bandwidth_packet_loss(float value) {
  _has_bits_[0] |= 0x00000002u;
  low_bandwidth_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecController_Threshold::has_high_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FecController_Threshold::clear_high_bandwidth_bps() {
  high_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FecController_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
  return high_bandwidth_bps_;
}
inline void FecController_Threshold::set_high_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  high_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
}

// optional float high_bandwidth_packet_loss = 4;
inline bool FecController_Threshold::has_high_bandwidth_packet_loss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FecController_Threshold::clear_high_bandwidth_packet_loss() {
  high_bandwidth_packet_loss_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float FecController_Threshold::high_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
  return high_bandwidth_packet_loss_;
}
inline void FecController_Threshold::set_high_bandwidth_packet_loss(float value) {
  _has_bits_[0] |= 0x00000008u;
  high_bandwidth_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
}

// -------------------------------------------------------------------

// FecController

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
inline bool FecController::has_fec_enabling_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FecController::clear_fec_enabling_threshold() {
  if (fec_enabling_threshold_ != nullptr) fec_enabling_threshold_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_enabling_threshold() const {
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = fec_enabling_threshold_;
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold*>(
      &::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_enabling_threshold() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  _has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = fec_enabling_threshold_;
  fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_enabling_threshold() {
  _has_bits_[0] |= 0x00000001u;
  if (fec_enabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArenaNoVirtual());
    fec_enabling_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return fec_enabling_threshold_;
}
inline void FecController::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_enabling_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_enabling_threshold_;
  }
  if (fec_enabling_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_enabling_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_enabling_threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fec_enabling_threshold_ = fec_enabling_threshold;
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
inline bool FecController::has_fec_disabling_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FecController::clear_fec_disabling_threshold() {
  if (fec_disabling_threshold_ != nullptr) fec_disabling_threshold_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_disabling_threshold() const {
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = fec_disabling_threshold_;
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold*>(
      &::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_disabling_threshold() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  _has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = fec_disabling_threshold_;
  fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_disabling_threshold() {
  _has_bits_[0] |= 0x00000002u;
  if (fec_disabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArenaNoVirtual());
    fec_disabling_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return fec_disabling_threshold_;
}
inline void FecController::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_disabling_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_disabling_threshold_;
  }
  if (fec_disabling_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_disabling_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_disabling_threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fec_disabling_threshold_ = fec_disabling_threshold;
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
}

// optional int32 time_constant_ms = 3;
inline bool FecController::has_time_constant_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FecController::clear_time_constant_ms() {
  time_constant_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FecController::time_constant_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
  return time_constant_ms_;
}
inline void FecController::set_time_constant_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  time_constant_ms_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
}

// -------------------------------------------------------------------

// FecControllerRplrBased_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_bps() {
  low_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FecControllerRplrBased_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
  return low_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  low_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
}

// optional float low_bandwidth_recoverable_packet_loss = 2;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_recoverable_packet_loss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_recoverable_packet_loss() {
  low_bandwidth_recoverable_packet_loss_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float FecControllerRplrBased_Threshold::low_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
  return low_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_recoverable_packet_loss(float value) {
  _has_bits_[0] |= 0x00000002u;
  low_bandwidth_recoverable_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_bps() {
  high_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FecControllerRplrBased_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
  return high_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  high_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
}

// optional float high_bandwidth_recoverable_packet_loss = 4;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_recoverable_packet_loss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_recoverable_packet_loss() {
  high_bandwidth_recoverable_packet_loss_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float FecControllerRplrBased_Threshold::high_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
  return high_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_recoverable_packet_loss(float value) {
  _has_bits_[0] |= 0x00000008u;
  high_bandwidth_recoverable_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
}

// -------------------------------------------------------------------

// FecControllerRplrBased

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
inline bool FecControllerRplrBased::has_fec_enabling_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FecControllerRplrBased::clear_fec_enabling_threshold() {
  if (fec_enabling_threshold_ != nullptr) fec_enabling_threshold_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_enabling_threshold() const {
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = fec_enabling_threshold_;
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(
      &::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::release_fec_enabling_threshold() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  _has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = fec_enabling_threshold_;
  fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::mutable_fec_enabling_threshold() {
  _has_bits_[0] |= 0x00000001u;
  if (fec_enabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArenaNoVirtual());
    fec_enabling_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return fec_enabling_threshold_;
}
inline void FecControllerRplrBased::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_enabling_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_enabling_threshold_;
  }
  if (fec_enabling_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_enabling_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_enabling_threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fec_enabling_threshold_ = fec_enabling_threshold;
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
inline bool FecControllerRplrBased::has_fec_disabling_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FecControllerRplrBased::clear_fec_disabling_threshold() {
  if (fec_disabling_threshold_ != nullptr) fec_disabling_threshold_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_disabling_threshold() const {
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = fec_disabling_threshold_;
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(
      &::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::release_fec_disabling_threshold() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  _has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = fec_disabling_threshold_;
  fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::mutable_fec_disabling_threshold() {
  _has_bits_[0] |= 0x00000002u;
  if (fec_disabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArenaNoVirtual());
    fec_disabling_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return fec_disabling_threshold_;
}
inline void FecControllerRplrBased::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_disabling_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_disabling_threshold_;
  }
  if (fec_disabling_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_disabling_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fec_disabling_threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fec_disabling_threshold_ = fec_disabling_threshold;
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
}

// -------------------------------------------------------------------

// FrameLengthController

// optional float fl_increasing_packet_loss_fraction = 1;
inline bool FrameLengthController::has_fl_increasing_packet_loss_fraction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameLengthController::clear_fl_increasing_packet_loss_fraction() {
  fl_increasing_packet_loss_fraction_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float FrameLengthController::fl_increasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
  return fl_increasing_packet_loss_fraction_;
}
inline void FrameLengthController::set_fl_increasing_packet_loss_fraction(float value) {
  _has_bits_[0] |= 0x00000001u;
  fl_increasing_packet_loss_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
}

// optional float fl_decreasing_packet_loss_fraction = 2;
inline bool FrameLengthController::has_fl_decreasing_packet_loss_fraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameLengthController::clear_fl_decreasing_packet_loss_fraction() {
  fl_decreasing_packet_loss_fraction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float FrameLengthController::fl_decreasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
  return fl_decreasing_packet_loss_fraction_;
}
inline void FrameLengthController::set_fl_decreasing_packet_loss_fraction(float value) {
  _has_bits_[0] |= 0x00000002u;
  fl_decreasing_packet_loss_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
}

// optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
inline bool FrameLengthController::has_fl_20ms_to_60ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameLengthController::clear_fl_20ms_to_60ms_bandwidth_bps() {
  fl_20ms_to_60ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_20ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
  return fl_20ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_20ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  fl_20ms_to_60ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
}

// optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
inline bool FrameLengthController::has_fl_60ms_to_20ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameLengthController::clear_fl_60ms_to_20ms_bandwidth_bps() {
  fl_60ms_to_20ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_60ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
  return fl_60ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_60ms_to_20ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  fl_60ms_to_20ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
}

// optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
inline bool FrameLengthController::has_fl_60ms_to_120ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameLengthController::clear_fl_60ms_to_120ms_bandwidth_bps() {
  fl_60ms_to_120ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_60ms_to_120ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
  return fl_60ms_to_120ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_60ms_to_120ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  fl_60ms_to_120ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
}

// optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
inline bool FrameLengthController::has_fl_120ms_to_60ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameLengthController::clear_fl_120ms_to_60ms_bandwidth_bps() {
  fl_120ms_to_60ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_120ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
  return fl_120ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_120ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  fl_120ms_to_60ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
}

// optional int32 fl_increase_overhead_offset = 7;
inline bool FrameLengthController::has_fl_increase_overhead_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrameLengthController::clear_fl_increase_overhead_offset() {
  fl_increase_overhead_offset_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
  return fl_increase_overhead_offset_;
}
inline void FrameLengthController::set_fl_increase_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  fl_increase_overhead_offset_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
}

// optional int32 fl_decrease_overhead_offset = 8;
inline bool FrameLengthController::has_fl_decrease_overhead_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameLengthController::clear_fl_decrease_overhead_offset() {
  fl_decrease_overhead_offset_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
  return fl_decrease_overhead_offset_;
}
inline void FrameLengthController::set_fl_decrease_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  fl_decrease_overhead_offset_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
}

// optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
inline bool FrameLengthController::has_fl_20ms_to_40ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FrameLengthController::clear_fl_20ms_to_40ms_bandwidth_bps() {
  fl_20ms_to_40ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_20ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
  return fl_20ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_20ms_to_40ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  fl_20ms_to_40ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
}

// optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
inline bool FrameLengthController::has_fl_40ms_to_20ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FrameLengthController::clear_fl_40ms_to_20ms_bandwidth_bps() {
  fl_40ms_to_20ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_40ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
  return fl_40ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_40ms_to_20ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  fl_40ms_to_20ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
}

// optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
inline bool FrameLengthController::has_fl_40ms_to_60ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FrameLengthController::clear_fl_40ms_to_60ms_bandwidth_bps() {
  fl_40ms_to_60ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_40ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
  return fl_40ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_40ms_to_60ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  fl_40ms_to_60ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
}

// optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
inline bool FrameLengthController::has_fl_60ms_to_40ms_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FrameLengthController::clear_fl_60ms_to_40ms_bandwidth_bps() {
  fl_60ms_to_40ms_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FrameLengthController::fl_60ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
  return fl_60ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::set_fl_60ms_to_40ms_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  fl_60ms_to_40ms_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
}

// -------------------------------------------------------------------

// ChannelController

// optional int32 channel_1_to_2_bandwidth_bps = 1;
inline bool ChannelController::has_channel_1_to_2_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelController::clear_channel_1_to_2_bandwidth_bps() {
  channel_1_to_2_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelController::channel_1_to_2_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
  return channel_1_to_2_bandwidth_bps_;
}
inline void ChannelController::set_channel_1_to_2_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_1_to_2_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
}

// optional int32 channel_2_to_1_bandwidth_bps = 2;
inline bool ChannelController::has_channel_2_to_1_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelController::clear_channel_2_to_1_bandwidth_bps() {
  channel_2_to_1_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelController::channel_2_to_1_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
  return channel_2_to_1_bandwidth_bps_;
}
inline void ChannelController::set_channel_2_to_1_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  channel_2_to_1_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
}

// -------------------------------------------------------------------

// DtxController

// optional int32 dtx_enabling_bandwidth_bps = 1;
inline bool DtxController::has_dtx_enabling_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtxController::clear_dtx_enabling_bandwidth_bps() {
  dtx_enabling_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DtxController::dtx_enabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
  return dtx_enabling_bandwidth_bps_;
}
inline void DtxController::set_dtx_enabling_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  dtx_enabling_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
}

// optional int32 dtx_disabling_bandwidth_bps = 2;
inline bool DtxController::has_dtx_disabling_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtxController::clear_dtx_disabling_bandwidth_bps() {
  dtx_disabling_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DtxController::dtx_disabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
  return dtx_disabling_bandwidth_bps_;
}
inline void DtxController::set_dtx_disabling_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  dtx_disabling_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
}

// -------------------------------------------------------------------

// BitrateController

// optional int32 fl_increase_overhead_offset = 1;
inline bool BitrateController::has_fl_increase_overhead_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitrateController::clear_fl_increase_overhead_offset() {
  fl_increase_overhead_offset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BitrateController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
  return fl_increase_overhead_offset_;
}
inline void BitrateController::set_fl_increase_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  fl_increase_overhead_offset_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
}

// optional int32 fl_decrease_overhead_offset = 2;
inline bool BitrateController::has_fl_decrease_overhead_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitrateController::clear_fl_decrease_overhead_offset() {
  fl_decrease_overhead_offset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BitrateController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
  return fl_decrease_overhead_offset_;
}
inline void BitrateController::set_fl_decrease_overhead_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  fl_decrease_overhead_offset_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
}

// -------------------------------------------------------------------

// Controller_ScoringPoint

// optional int32 uplink_bandwidth_bps = 1;
inline bool Controller_ScoringPoint::has_uplink_bandwidth_bps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Controller_ScoringPoint::clear_uplink_bandwidth_bps() {
  uplink_bandwidth_bps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Controller_ScoringPoint::uplink_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
  return uplink_bandwidth_bps_;
}
inline void Controller_ScoringPoint::set_uplink_bandwidth_bps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  uplink_bandwidth_bps_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
}

// optional float uplink_packet_loss_fraction = 2;
inline bool Controller_ScoringPoint::has_uplink_packet_loss_fraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Controller_ScoringPoint::clear_uplink_packet_loss_fraction() {
  uplink_packet_loss_fraction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Controller_ScoringPoint::uplink_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
  return uplink_packet_loss_fraction_;
}
inline void Controller_ScoringPoint::set_uplink_packet_loss_fraction(float value) {
  _has_bits_[0] |= 0x00000002u;
  uplink_packet_loss_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
}

// -------------------------------------------------------------------

// Controller

// optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
inline bool Controller::has_scoring_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Controller::clear_scoring_point() {
  if (scoring_point_ != nullptr) scoring_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::scoring_point() const {
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* p = scoring_point_;
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(
      &::webrtc::audio_network_adaptor::config::_Controller_ScoringPoint_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::release_scoring_point() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  _has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* temp = scoring_point_;
  scoring_point_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::mutable_scoring_point() {
  _has_bits_[0] |= 0x00000001u;
  if (scoring_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint>(GetArenaNoVirtual());
    scoring_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return scoring_point_;
}
inline void Controller::set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* scoring_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete scoring_point_;
  }
  if (scoring_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scoring_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scoring_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scoring_point_ = scoring_point;
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
}

// optional .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
inline bool Controller::has_fec_controller() const {
  return controller_case() == kFecController;
}
inline void Controller::set_has_fec_controller() {
  _oneof_case_[0] = kFecController;
}
inline void Controller::clear_fec_controller() {
  if (has_fec_controller()) {
    delete controller_.fec_controller_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::release_fec_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  if (has_fec_controller()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::FecController* temp = controller_.fec_controller_;
    controller_.fec_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecController& Controller::fec_controller() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return has_fec_controller()
      ? *controller_.fec_controller_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::FecController*>(&::webrtc::audio_network_adaptor::config::_FecController_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::mutable_fec_controller() {
  if (!has_fec_controller()) {
    clear_controller();
    set_has_fec_controller();
    controller_.fec_controller_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::FecController >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return controller_.fec_controller_;
}

// optional .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
inline bool Controller::has_frame_length_controller() const {
  return controller_case() == kFrameLengthController;
}
inline void Controller::set_has_frame_length_controller() {
  _oneof_case_[0] = kFrameLengthController;
}
inline void Controller::clear_frame_length_controller() {
  if (has_frame_length_controller()) {
    delete controller_.frame_length_controller_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::release_frame_length_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  if (has_frame_length_controller()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::FrameLengthController* temp = controller_.frame_length_controller_;
    controller_.frame_length_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::frame_length_controller() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return has_frame_length_controller()
      ? *controller_.frame_length_controller_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::FrameLengthController*>(&::webrtc::audio_network_adaptor::config::_FrameLengthController_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::mutable_frame_length_controller() {
  if (!has_frame_length_controller()) {
    clear_controller();
    set_has_frame_length_controller();
    controller_.frame_length_controller_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::FrameLengthController >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return controller_.frame_length_controller_;
}

// optional .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
inline bool Controller::has_channel_controller() const {
  return controller_case() == kChannelController;
}
inline void Controller::set_has_channel_controller() {
  _oneof_case_[0] = kChannelController;
}
inline void Controller::clear_channel_controller() {
  if (has_channel_controller()) {
    delete controller_.channel_controller_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::release_channel_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  if (has_channel_controller()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::ChannelController* temp = controller_.channel_controller_;
    controller_.channel_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::channel_controller() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return has_channel_controller()
      ? *controller_.channel_controller_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::ChannelController*>(&::webrtc::audio_network_adaptor::config::_ChannelController_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::mutable_channel_controller() {
  if (!has_channel_controller()) {
    clear_controller();
    set_has_channel_controller();
    controller_.channel_controller_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::ChannelController >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return controller_.channel_controller_;
}

// optional .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
inline bool Controller::has_dtx_controller() const {
  return controller_case() == kDtxController;
}
inline void Controller::set_has_dtx_controller() {
  _oneof_case_[0] = kDtxController;
}
inline void Controller::clear_dtx_controller() {
  if (has_dtx_controller()) {
    delete controller_.dtx_controller_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::release_dtx_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  if (has_dtx_controller()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::DtxController* temp = controller_.dtx_controller_;
    controller_.dtx_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::DtxController& Controller::dtx_controller() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return has_dtx_controller()
      ? *controller_.dtx_controller_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::DtxController*>(&::webrtc::audio_network_adaptor::config::_DtxController_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::mutable_dtx_controller() {
  if (!has_dtx_controller()) {
    clear_controller();
    set_has_dtx_controller();
    controller_.dtx_controller_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::DtxController >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return controller_.dtx_controller_;
}

// optional .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
inline bool Controller::has_bitrate_controller() const {
  return controller_case() == kBitrateController;
}
inline void Controller::set_has_bitrate_controller() {
  _oneof_case_[0] = kBitrateController;
}
inline void Controller::clear_bitrate_controller() {
  if (has_bitrate_controller()) {
    delete controller_.bitrate_controller_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::release_bitrate_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  if (has_bitrate_controller()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::BitrateController* temp = controller_.bitrate_controller_;
    controller_.bitrate_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::bitrate_controller() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return has_bitrate_controller()
      ? *controller_.bitrate_controller_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::BitrateController*>(&::webrtc::audio_network_adaptor::config::_BitrateController_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::mutable_bitrate_controller() {
  if (!has_bitrate_controller()) {
    clear_controller();
    set_has_bitrate_controller();
    controller_.bitrate_controller_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::BitrateController >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return controller_.bitrate_controller_;
}

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
inline bool Controller::has_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased;
}
inline void Controller::set_has_fec_controller_rplr_based() {
  _oneof_case_[0] = kFecControllerRplrBased;
}
inline void Controller::clear_fec_controller_rplr_based() {
  if (has_fec_controller_rplr_based()) {
    delete controller_.fec_controller_rplr_based_;
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::release_fec_controller_rplr_based() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  if (has_fec_controller_rplr_based()) {
    clear_has_controller();
      ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* temp = controller_.fec_controller_rplr_based_;
    controller_.fec_controller_rplr_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& Controller::fec_controller_rplr_based() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return has_fec_controller_rplr_based()
      ? *controller_.fec_controller_rplr_based_
      : *reinterpret_cast< ::webrtc::audio_network_adaptor::config::FecControllerRplrBased*>(&::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_default_instance_);
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::mutable_fec_controller_rplr_based() {
  if (!has_fec_controller_rplr_based()) {
    clear_controller();
    set_has_fec_controller_rplr_based();
    controller_.fec_controller_rplr_based_ = CreateMaybeMessage< ::webrtc::audio_network_adaptor::config::FecControllerRplrBased >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return controller_.fec_controller_rplr_based_;
}

inline bool Controller::has_controller() const {
  return controller_case() != CONTROLLER_NOT_SET;
}
inline void Controller::clear_has_controller() {
  _oneof_case_[0] = CONTROLLER_NOT_SET;
}
inline Controller::ControllerCase Controller::controller_case() const {
  return Controller::ControllerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControllerManager

// repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
inline int ControllerManager::controllers_size() const {
  return controllers_.size();
}
inline void ControllerManager::clear_controllers() {
  controllers_.Clear();
}
inline ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::mutable_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >*
ControllerManager::mutable_controllers() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return &controllers_;
}
inline const ::webrtc::audio_network_adaptor::config::Controller& ControllerManager::controllers(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return controllers_.Get(index);
}
inline ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::add_controllers() {
  // @@protoc_insertion_point(field_add:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return controllers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >&
ControllerManager::controllers() const {
  // @@protoc_insertion_point(field_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return controllers_;
}

// optional int32 min_reordering_time_ms = 2;
inline bool ControllerManager::has_min_reordering_time_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerManager::clear_min_reordering_time_ms() {
  min_reordering_time_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControllerManager::min_reordering_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
  return min_reordering_time_ms_;
}
inline void ControllerManager::set_min_reordering_time_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  min_reordering_time_ms_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
}

// optional float min_reordering_squared_distance = 3;
inline bool ControllerManager::has_min_reordering_squared_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerManager::clear_min_reordering_squared_distance() {
  min_reordering_squared_distance_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ControllerManager::min_reordering_squared_distance() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
  return min_reordering_squared_distance_;
}
inline void ControllerManager::set_min_reordering_squared_distance(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_reordering_squared_distance_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_config_2eproto
