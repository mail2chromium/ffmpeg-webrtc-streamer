// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: histogram.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_histogram_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_histogram_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {
class Bin;
class BinDefaultTypeInternal;
extern BinDefaultTypeInternal _Bin_default_instance_;
class BinBoundaries;
class BinBoundariesDefaultTypeInternal;
extern BinBoundariesDefaultTypeInternal _BinBoundaries_default_instance_;
class BinBoundaryDetailedSpec;
class BinBoundaryDetailedSpecDefaultTypeInternal;
extern BinBoundaryDetailedSpecDefaultTypeInternal _BinBoundaryDetailedSpec_default_instance_;
class BinBoundarySpec;
class BinBoundarySpecDefaultTypeInternal;
extern BinBoundarySpecDefaultTypeInternal _BinBoundarySpec_default_instance_;
class Breakdown;
class BreakdownDefaultTypeInternal;
extern BreakdownDefaultTypeInternal _Breakdown_default_instance_;
class DateRange;
class DateRangeDefaultTypeInternal;
extern DateRangeDefaultTypeInternal _DateRange_default_instance_;
class Diagnostic;
class DiagnosticDefaultTypeInternal;
extern DiagnosticDefaultTypeInternal _Diagnostic_default_instance_;
class DiagnosticMap;
class DiagnosticMapDefaultTypeInternal;
extern DiagnosticMapDefaultTypeInternal _DiagnosticMap_default_instance_;
class DiagnosticMap_DiagnosticMapEntry_DoNotUse;
class DiagnosticMap_DiagnosticMapEntry_DoNotUseDefaultTypeInternal;
extern DiagnosticMap_DiagnosticMapEntry_DoNotUseDefaultTypeInternal _DiagnosticMap_DiagnosticMapEntry_DoNotUse_default_instance_;
class GenericSet;
class GenericSetDefaultTypeInternal;
extern GenericSetDefaultTypeInternal _GenericSet_default_instance_;
class Histogram;
class HistogramDefaultTypeInternal;
extern HistogramDefaultTypeInternal _Histogram_default_instance_;
class HistogramSet;
class HistogramSetDefaultTypeInternal;
extern HistogramSetDefaultTypeInternal _HistogramSet_default_instance_;
class HistogramSet_SharedDiagnosticsEntry_DoNotUse;
class HistogramSet_SharedDiagnosticsEntry_DoNotUseDefaultTypeInternal;
extern HistogramSet_SharedDiagnosticsEntry_DoNotUseDefaultTypeInternal _HistogramSet_SharedDiagnosticsEntry_DoNotUse_default_instance_;
class Histogram_AllBinsEntry_DoNotUse;
class Histogram_AllBinsEntry_DoNotUseDefaultTypeInternal;
extern Histogram_AllBinsEntry_DoNotUseDefaultTypeInternal _Histogram_AllBinsEntry_DoNotUse_default_instance_;
class RelatedEventSet;
class RelatedEventSetDefaultTypeInternal;
extern RelatedEventSetDefaultTypeInternal _RelatedEventSet_default_instance_;
class RelatedNameMap;
class RelatedNameMapDefaultTypeInternal;
extern RelatedNameMapDefaultTypeInternal _RelatedNameMap_default_instance_;
class RunningStatistics;
class RunningStatisticsDefaultTypeInternal;
extern RunningStatisticsDefaultTypeInternal _RunningStatistics_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class SummaryOptions;
class SummaryOptionsDefaultTypeInternal;
extern SummaryOptionsDefaultTypeInternal _SummaryOptions_default_instance_;
class UnitAndDirection;
class UnitAndDirectionDefaultTypeInternal;
extern UnitAndDirectionDefaultTypeInternal _UnitAndDirection_default_instance_;
}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult
PROTOBUF_NAMESPACE_OPEN
template<> ::catapult::tracing::tracing::proto::Bin* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Bin>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundaries* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaries>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec>(Arena*);
template<> ::catapult::tracing::tracing::proto::BinBoundarySpec* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundarySpec>(Arena*);
template<> ::catapult::tracing::tracing::proto::Breakdown* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Breakdown>(Arena*);
template<> ::catapult::tracing::tracing::proto::DateRange* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DateRange>(Arena*);
template<> ::catapult::tracing::tracing::proto::Diagnostic* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Diagnostic>(Arena*);
template<> ::catapult::tracing::tracing::proto::DiagnosticMap* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap>(Arena*);
template<> ::catapult::tracing::tracing::proto::DiagnosticMap_DiagnosticMapEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap_DiagnosticMapEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::GenericSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::GenericSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::Histogram* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Histogram>(Arena*);
template<> ::catapult::tracing::tracing::proto::HistogramSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::HistogramSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::HistogramSet_SharedDiagnosticsEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::HistogramSet_SharedDiagnosticsEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::Histogram_AllBinsEntry_DoNotUse* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Histogram_AllBinsEntry_DoNotUse>(Arena*);
template<> ::catapult::tracing::tracing::proto::RelatedEventSet* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RelatedEventSet>(Arena*);
template<> ::catapult::tracing::tracing::proto::RelatedNameMap* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RelatedNameMap>(Arena*);
template<> ::catapult::tracing::tracing::proto::RunningStatistics* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::RunningStatistics>(Arena*);
template<> ::catapult::tracing::tracing::proto::Scalar* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::Scalar>(Arena*);
template<> ::catapult::tracing::tracing::proto::SummaryOptions* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::SummaryOptions>(Arena*);
template<> ::catapult::tracing::tracing::proto::UnitAndDirection* Arena::CreateMaybeMessage<::catapult::tracing::tracing::proto::UnitAndDirection>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {

enum BinBoundaryDetailedSpec_Type : int {
  BinBoundaryDetailedSpec_Type_LINEAR = 0,
  BinBoundaryDetailedSpec_Type_EXPONENTIAL = 1,
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinBoundaryDetailedSpec_Type_IsValid(int value);
constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MIN = BinBoundaryDetailedSpec_Type_LINEAR;
constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MAX = BinBoundaryDetailedSpec_Type_EXPONENTIAL;
constexpr int BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE = BinBoundaryDetailedSpec_Type_Type_MAX + 1;

const std::string& BinBoundaryDetailedSpec_Type_Name(BinBoundaryDetailedSpec_Type value);
template<typename T>
inline const std::string& BinBoundaryDetailedSpec_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinBoundaryDetailedSpec_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinBoundaryDetailedSpec_Type_Name.");
  return BinBoundaryDetailedSpec_Type_Name(static_cast<BinBoundaryDetailedSpec_Type>(enum_t_value));
}
bool BinBoundaryDetailedSpec_Type_Parse(
    const std::string& name, BinBoundaryDetailedSpec_Type* value);
enum ImprovementDirection : int {
  NOT_SPECIFIED = 0,
  BIGGER_IS_BETTER = 1,
  SMALLER_IS_BETTER = 2,
  ImprovementDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImprovementDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImprovementDirection_IsValid(int value);
constexpr ImprovementDirection ImprovementDirection_MIN = NOT_SPECIFIED;
constexpr ImprovementDirection ImprovementDirection_MAX = SMALLER_IS_BETTER;
constexpr int ImprovementDirection_ARRAYSIZE = ImprovementDirection_MAX + 1;

const std::string& ImprovementDirection_Name(ImprovementDirection value);
template<typename T>
inline const std::string& ImprovementDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImprovementDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImprovementDirection_Name.");
  return ImprovementDirection_Name(static_cast<ImprovementDirection>(enum_t_value));
}
bool ImprovementDirection_Parse(
    const std::string& name, ImprovementDirection* value);
enum Unit : int {
  MS = 0,
  MS_BEST_FIT_FORMAT = 1,
  TS_MS = 2,
  N_PERCENT = 3,
  SIZE_IN_BYTES = 4,
  BYTES_PER_SECOND = 5,
  J = 6,
  W = 7,
  A = 8,
  V = 9,
  HERTZ = 10,
  UNITLESS = 11,
  COUNT = 12,
  SIGMA = 13,
  Unit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Unit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Unit_IsValid(int value);
constexpr Unit Unit_MIN = MS;
constexpr Unit Unit_MAX = SIGMA;
constexpr int Unit_ARRAYSIZE = Unit_MAX + 1;

const std::string& Unit_Name(Unit value);
template<typename T>
inline const std::string& Unit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Unit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Unit_Name.");
  return Unit_Name(static_cast<Unit>(enum_t_value));
}
bool Unit_Parse(
    const std::string& name, Unit* value);
// ===================================================================

class UnitAndDirection :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.UnitAndDirection) */ {
 public:
  UnitAndDirection();
  virtual ~UnitAndDirection();

  UnitAndDirection(const UnitAndDirection& from);
  UnitAndDirection(UnitAndDirection&& from) noexcept
    : UnitAndDirection() {
    *this = ::std::move(from);
  }

  inline UnitAndDirection& operator=(const UnitAndDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitAndDirection& operator=(UnitAndDirection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UnitAndDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitAndDirection* internal_default_instance() {
    return reinterpret_cast<const UnitAndDirection*>(
               &_UnitAndDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UnitAndDirection& a, UnitAndDirection& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitAndDirection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitAndDirection* New() const final {
    return CreateMaybeMessage<UnitAndDirection>(nullptr);
  }

  UnitAndDirection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitAndDirection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UnitAndDirection& from);
  void MergeFrom(const UnitAndDirection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnitAndDirection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.UnitAndDirection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kImprovementDirectionFieldNumber = 2,
  };
  // .catapult.tracing.tracing.proto.Unit unit = 1;
  void clear_unit();
  ::catapult::tracing::tracing::proto::Unit unit() const;
  void set_unit(::catapult::tracing::tracing::proto::Unit value);

  // .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
  void clear_improvement_direction();
  ::catapult::tracing::tracing::proto::ImprovementDirection improvement_direction() const;
  void set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.UnitAndDirection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int unit_;
  int improvement_direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundaryDetailedSpec :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec) */ {
 public:
  BinBoundaryDetailedSpec();
  virtual ~BinBoundaryDetailedSpec();

  BinBoundaryDetailedSpec(const BinBoundaryDetailedSpec& from);
  BinBoundaryDetailedSpec(BinBoundaryDetailedSpec&& from) noexcept
    : BinBoundaryDetailedSpec() {
    *this = ::std::move(from);
  }

  inline BinBoundaryDetailedSpec& operator=(const BinBoundaryDetailedSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaryDetailedSpec& operator=(BinBoundaryDetailedSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundaryDetailedSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinBoundaryDetailedSpec* internal_default_instance() {
    return reinterpret_cast<const BinBoundaryDetailedSpec*>(
               &_BinBoundaryDetailedSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BinBoundaryDetailedSpec& a, BinBoundaryDetailedSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(BinBoundaryDetailedSpec* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundaryDetailedSpec* New() const final {
    return CreateMaybeMessage<BinBoundaryDetailedSpec>(nullptr);
  }

  BinBoundaryDetailedSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundaryDetailedSpec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundaryDetailedSpec& from);
  void MergeFrom(const BinBoundaryDetailedSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundaryDetailedSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundaryDetailedSpec";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BinBoundaryDetailedSpec_Type Type;
  static constexpr Type LINEAR =
    BinBoundaryDetailedSpec_Type_LINEAR;
  static constexpr Type EXPONENTIAL =
    BinBoundaryDetailedSpec_Type_EXPONENTIAL;
  static inline bool Type_IsValid(int value) {
    return BinBoundaryDetailedSpec_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BinBoundaryDetailedSpec_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BinBoundaryDetailedSpec_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BinBoundaryDetailedSpec_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return BinBoundaryDetailedSpec_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumBinBoundaryFieldNumber = 2,
    kBoundaryTypeFieldNumber = 1,
    kNumBinBoundariesFieldNumber = 3,
  };
  // double maximum_bin_boundary = 2;
  void clear_maximum_bin_boundary();
  double maximum_bin_boundary() const;
  void set_maximum_bin_boundary(double value);

  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
  void clear_boundary_type();
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type boundary_type() const;
  void set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value);

  // int32 num_bin_boundaries = 3;
  void clear_num_bin_boundaries();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bin_boundaries() const;
  void set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  double maximum_bin_boundary_;
  int boundary_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bin_boundaries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundarySpec :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundarySpec) */ {
 public:
  BinBoundarySpec();
  virtual ~BinBoundarySpec();

  BinBoundarySpec(const BinBoundarySpec& from);
  BinBoundarySpec(BinBoundarySpec&& from) noexcept
    : BinBoundarySpec() {
    *this = ::std::move(from);
  }

  inline BinBoundarySpec& operator=(const BinBoundarySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundarySpec& operator=(BinBoundarySpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundarySpec& default_instance();

  enum BoundaryOneofCase {
    kBinBoundary = 1,
    kBinSpec = 2,
    BOUNDARY_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinBoundarySpec* internal_default_instance() {
    return reinterpret_cast<const BinBoundarySpec*>(
               &_BinBoundarySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BinBoundarySpec& a, BinBoundarySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(BinBoundarySpec* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundarySpec* New() const final {
    return CreateMaybeMessage<BinBoundarySpec>(nullptr);
  }

  BinBoundarySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundarySpec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundarySpec& from);
  void MergeFrom(const BinBoundarySpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundarySpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundarySpec";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinBoundaryFieldNumber = 1,
    kBinSpecFieldNumber = 2,
  };
  // double bin_boundary = 1;
  private:
  bool has_bin_boundary() const;
  public:
  void clear_bin_boundary();
  double bin_boundary() const;
  void set_bin_boundary(double value);

  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
  bool has_bin_spec() const;
  void clear_bin_spec();
  const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& bin_spec() const;
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* release_bin_spec();
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* mutable_bin_spec();
  void set_allocated_bin_spec(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec);

  void clear_boundary_oneof();
  BoundaryOneofCase boundary_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundarySpec)
 private:
  class _Internal;
  void set_has_bin_boundary();
  void set_has_bin_spec();

  inline bool has_boundary_oneof() const;
  inline void clear_has_boundary_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union BoundaryOneofUnion {
    BoundaryOneofUnion() {}
    double bin_boundary_;
    ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* bin_spec_;
  } boundary_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class BinBoundaries :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaries) */ {
 public:
  BinBoundaries();
  virtual ~BinBoundaries();

  BinBoundaries(const BinBoundaries& from);
  BinBoundaries(BinBoundaries&& from) noexcept
    : BinBoundaries() {
    *this = ::std::move(from);
  }

  inline BinBoundaries& operator=(const BinBoundaries& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaries& operator=(BinBoundaries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const BinBoundaries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinBoundaries* internal_default_instance() {
    return reinterpret_cast<const BinBoundaries*>(
               &_BinBoundaries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BinBoundaries& a, BinBoundaries& b) {
    a.Swap(&b);
  }
  inline void Swap(BinBoundaries* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinBoundaries* New() const final {
    return CreateMaybeMessage<BinBoundaries>(nullptr);
  }

  BinBoundaries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinBoundaries>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinBoundaries& from);
  void MergeFrom(const BinBoundaries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinBoundaries* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.BinBoundaries";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinSpecsFieldNumber = 2,
    kFirstBinBoundaryFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
  int bin_specs_size() const;
  void clear_bin_specs();
  ::catapult::tracing::tracing::proto::BinBoundarySpec* mutable_bin_specs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >*
      mutable_bin_specs();
  const ::catapult::tracing::tracing::proto::BinBoundarySpec& bin_specs(int index) const;
  ::catapult::tracing::tracing::proto::BinBoundarySpec* add_bin_specs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >&
      bin_specs() const;

  // double first_bin_boundary = 1;
  void clear_first_bin_boundary();
  double first_bin_boundary() const;
  void set_first_bin_boundary(double value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaries)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec > bin_specs_;
  double first_bin_boundary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Breakdown :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Breakdown) */ {
 public:
  Breakdown();
  virtual ~Breakdown();

  Breakdown(const Breakdown& from);
  Breakdown(Breakdown&& from) noexcept
    : Breakdown() {
    *this = ::std::move(from);
  }

  inline Breakdown& operator=(const Breakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline Breakdown& operator=(Breakdown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Breakdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Breakdown* internal_default_instance() {
    return reinterpret_cast<const Breakdown*>(
               &_Breakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Breakdown& a, Breakdown& b) {
    a.Swap(&b);
  }
  inline void Swap(Breakdown* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Breakdown* New() const final {
    return CreateMaybeMessage<Breakdown>(nullptr);
  }

  Breakdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Breakdown>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Breakdown& from);
  void MergeFrom(const Breakdown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Breakdown* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Breakdown";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Breakdown)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class DateRange :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DateRange) */ {
 public:
  DateRange();
  virtual ~DateRange();

  DateRange(const DateRange& from);
  DateRange(DateRange&& from) noexcept
    : DateRange() {
    *this = ::std::move(from);
  }

  inline DateRange& operator=(const DateRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateRange& operator=(DateRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DateRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DateRange* internal_default_instance() {
    return reinterpret_cast<const DateRange*>(
               &_DateRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DateRange& a, DateRange& b) {
    a.Swap(&b);
  }
  inline void Swap(DateRange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DateRange* New() const final {
    return CreateMaybeMessage<DateRange>(nullptr);
  }

  DateRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DateRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DateRange& from);
  void MergeFrom(const DateRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.DateRange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DateRange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class GenericSet :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.GenericSet) */ {
 public:
  GenericSet();
  virtual ~GenericSet();

  GenericSet(const GenericSet& from);
  GenericSet(GenericSet&& from) noexcept
    : GenericSet() {
    *this = ::std::move(from);
  }

  inline GenericSet& operator=(const GenericSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericSet& operator=(GenericSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GenericSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericSet* internal_default_instance() {
    return reinterpret_cast<const GenericSet*>(
               &_GenericSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenericSet& a, GenericSet& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericSet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericSet* New() const final {
    return CreateMaybeMessage<GenericSet>(nullptr);
  }

  GenericSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GenericSet& from);
  void MergeFrom(const GenericSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.GenericSet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.GenericSet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RelatedEventSet :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedEventSet) */ {
 public:
  RelatedEventSet();
  virtual ~RelatedEventSet();

  RelatedEventSet(const RelatedEventSet& from);
  RelatedEventSet(RelatedEventSet&& from) noexcept
    : RelatedEventSet() {
    *this = ::std::move(from);
  }

  inline RelatedEventSet& operator=(const RelatedEventSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedEventSet& operator=(RelatedEventSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelatedEventSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelatedEventSet* internal_default_instance() {
    return reinterpret_cast<const RelatedEventSet*>(
               &_RelatedEventSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RelatedEventSet& a, RelatedEventSet& b) {
    a.Swap(&b);
  }
  inline void Swap(RelatedEventSet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelatedEventSet* New() const final {
    return CreateMaybeMessage<RelatedEventSet>(nullptr);
  }

  RelatedEventSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelatedEventSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RelatedEventSet& from);
  void MergeFrom(const RelatedEventSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelatedEventSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RelatedEventSet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedEventSet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RelatedNameMap :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedNameMap) */ {
 public:
  RelatedNameMap();
  virtual ~RelatedNameMap();

  RelatedNameMap(const RelatedNameMap& from);
  RelatedNameMap(RelatedNameMap&& from) noexcept
    : RelatedNameMap() {
    *this = ::std::move(from);
  }

  inline RelatedNameMap& operator=(const RelatedNameMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedNameMap& operator=(RelatedNameMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RelatedNameMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelatedNameMap* internal_default_instance() {
    return reinterpret_cast<const RelatedNameMap*>(
               &_RelatedNameMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RelatedNameMap& a, RelatedNameMap& b) {
    a.Swap(&b);
  }
  inline void Swap(RelatedNameMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelatedNameMap* New() const final {
    return CreateMaybeMessage<RelatedNameMap>(nullptr);
  }

  RelatedNameMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelatedNameMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RelatedNameMap& from);
  void MergeFrom(const RelatedNameMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelatedNameMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RelatedNameMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedNameMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Scalar :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Scalar) */ {
 public:
  Scalar();
  virtual ~Scalar();

  Scalar(const Scalar& from);
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Scalar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }
  inline void Swap(Scalar* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const final {
    return CreateMaybeMessage<Scalar>(nullptr);
  }

  Scalar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scalar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Scalar";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Scalar)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Diagnostic :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Diagnostic) */ {
 public:
  Diagnostic();
  virtual ~Diagnostic();

  Diagnostic(const Diagnostic& from);
  Diagnostic(Diagnostic&& from) noexcept
    : Diagnostic() {
    *this = ::std::move(from);
  }

  inline Diagnostic& operator=(const Diagnostic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Diagnostic& operator=(Diagnostic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Diagnostic& default_instance();

  enum DiagnosticOneofCase {
    kBreakdown = 1,
    kDateRange = 2,
    kGenericSet = 3,
    kRelatedEventSet = 4,
    kRelatedNameMap = 5,
    kScalar = 6,
    kSharedDiagnosticGuid = 7,
    DIAGNOSTIC_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Diagnostic* internal_default_instance() {
    return reinterpret_cast<const Diagnostic*>(
               &_Diagnostic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Diagnostic& a, Diagnostic& b) {
    a.Swap(&b);
  }
  inline void Swap(Diagnostic* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Diagnostic* New() const final {
    return CreateMaybeMessage<Diagnostic>(nullptr);
  }

  Diagnostic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Diagnostic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Diagnostic& from);
  void MergeFrom(const Diagnostic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Diagnostic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Diagnostic";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakdownFieldNumber = 1,
    kDateRangeFieldNumber = 2,
    kGenericSetFieldNumber = 3,
    kRelatedEventSetFieldNumber = 4,
    kRelatedNameMapFieldNumber = 5,
    kScalarFieldNumber = 6,
    kSharedDiagnosticGuidFieldNumber = 7,
  };
  // .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
  bool has_breakdown() const;
  void clear_breakdown();
  const ::catapult::tracing::tracing::proto::Breakdown& breakdown() const;
  ::catapult::tracing::tracing::proto::Breakdown* release_breakdown();
  ::catapult::tracing::tracing::proto::Breakdown* mutable_breakdown();
  void set_allocated_breakdown(::catapult::tracing::tracing::proto::Breakdown* breakdown);

  // .catapult.tracing.tracing.proto.DateRange date_range = 2;
  bool has_date_range() const;
  void clear_date_range();
  const ::catapult::tracing::tracing::proto::DateRange& date_range() const;
  ::catapult::tracing::tracing::proto::DateRange* release_date_range();
  ::catapult::tracing::tracing::proto::DateRange* mutable_date_range();
  void set_allocated_date_range(::catapult::tracing::tracing::proto::DateRange* date_range);

  // .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
  bool has_generic_set() const;
  void clear_generic_set();
  const ::catapult::tracing::tracing::proto::GenericSet& generic_set() const;
  ::catapult::tracing::tracing::proto::GenericSet* release_generic_set();
  ::catapult::tracing::tracing::proto::GenericSet* mutable_generic_set();
  void set_allocated_generic_set(::catapult::tracing::tracing::proto::GenericSet* generic_set);

  // .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
  bool has_related_event_set() const;
  void clear_related_event_set();
  const ::catapult::tracing::tracing::proto::RelatedEventSet& related_event_set() const;
  ::catapult::tracing::tracing::proto::RelatedEventSet* release_related_event_set();
  ::catapult::tracing::tracing::proto::RelatedEventSet* mutable_related_event_set();
  void set_allocated_related_event_set(::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set);

  // .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
  bool has_related_name_map() const;
  void clear_related_name_map();
  const ::catapult::tracing::tracing::proto::RelatedNameMap& related_name_map() const;
  ::catapult::tracing::tracing::proto::RelatedNameMap* release_related_name_map();
  ::catapult::tracing::tracing::proto::RelatedNameMap* mutable_related_name_map();
  void set_allocated_related_name_map(::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map);

  // .catapult.tracing.tracing.proto.Scalar scalar = 6;
  bool has_scalar() const;
  void clear_scalar();
  const ::catapult::tracing::tracing::proto::Scalar& scalar() const;
  ::catapult::tracing::tracing::proto::Scalar* release_scalar();
  ::catapult::tracing::tracing::proto::Scalar* mutable_scalar();
  void set_allocated_scalar(::catapult::tracing::tracing::proto::Scalar* scalar);

  // string shared_diagnostic_guid = 7;
  private:
  bool has_shared_diagnostic_guid() const;
  public:
  void clear_shared_diagnostic_guid();
  const std::string& shared_diagnostic_guid() const;
  void set_shared_diagnostic_guid(const std::string& value);
  void set_shared_diagnostic_guid(std::string&& value);
  void set_shared_diagnostic_guid(const char* value);
  void set_shared_diagnostic_guid(const char* value, size_t size);
  std::string* mutable_shared_diagnostic_guid();
  std::string* release_shared_diagnostic_guid();
  void set_allocated_shared_diagnostic_guid(std::string* shared_diagnostic_guid);

  void clear_diagnostic_oneof();
  DiagnosticOneofCase diagnostic_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Diagnostic)
 private:
  class _Internal;
  void set_has_breakdown();
  void set_has_date_range();
  void set_has_generic_set();
  void set_has_related_event_set();
  void set_has_related_name_map();
  void set_has_scalar();
  void set_has_shared_diagnostic_guid();

  inline bool has_diagnostic_oneof() const;
  inline void clear_has_diagnostic_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union DiagnosticOneofUnion {
    DiagnosticOneofUnion() {}
    ::catapult::tracing::tracing::proto::Breakdown* breakdown_;
    ::catapult::tracing::tracing::proto::DateRange* date_range_;
    ::catapult::tracing::tracing::proto::GenericSet* generic_set_;
    ::catapult::tracing::tracing::proto::RelatedEventSet* related_event_set_;
    ::catapult::tracing::tracing::proto::RelatedNameMap* related_name_map_;
    ::catapult::tracing::tracing::proto::Scalar* scalar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_diagnostic_guid_;
  } diagnostic_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class DiagnosticMap_DiagnosticMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<DiagnosticMap_DiagnosticMapEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<DiagnosticMap_DiagnosticMapEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  DiagnosticMap_DiagnosticMapEntry_DoNotUse();
  DiagnosticMap_DiagnosticMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DiagnosticMap_DiagnosticMapEntry_DoNotUse& other);
  static const DiagnosticMap_DiagnosticMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DiagnosticMap_DiagnosticMapEntry_DoNotUse*>(&_DiagnosticMap_DiagnosticMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "catapult.tracing.tracing.proto.DiagnosticMap.DiagnosticMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class DiagnosticMap :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DiagnosticMap) */ {
 public:
  DiagnosticMap();
  virtual ~DiagnosticMap();

  DiagnosticMap(const DiagnosticMap& from);
  DiagnosticMap(DiagnosticMap&& from) noexcept
    : DiagnosticMap() {
    *this = ::std::move(from);
  }

  inline DiagnosticMap& operator=(const DiagnosticMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiagnosticMap& operator=(DiagnosticMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DiagnosticMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiagnosticMap* internal_default_instance() {
    return reinterpret_cast<const DiagnosticMap*>(
               &_DiagnosticMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DiagnosticMap& a, DiagnosticMap& b) {
    a.Swap(&b);
  }
  inline void Swap(DiagnosticMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiagnosticMap* New() const final {
    return CreateMaybeMessage<DiagnosticMap>(nullptr);
  }

  DiagnosticMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiagnosticMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DiagnosticMap& from);
  void MergeFrom(const DiagnosticMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiagnosticMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.DiagnosticMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticMapFieldNumber = 1,
  };
  // map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
  int diagnostic_map_size() const;
  void clear_diagnostic_map();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      diagnostic_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      mutable_diagnostic_map();

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DiagnosticMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      DiagnosticMap_DiagnosticMapEntry_DoNotUse,
      std::string, ::catapult::tracing::tracing::proto::Diagnostic,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > diagnostic_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class RunningStatistics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RunningStatistics) */ {
 public:
  RunningStatistics();
  virtual ~RunningStatistics();

  RunningStatistics(const RunningStatistics& from);
  RunningStatistics(RunningStatistics&& from) noexcept
    : RunningStatistics() {
    *this = ::std::move(from);
  }

  inline RunningStatistics& operator=(const RunningStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatistics& operator=(RunningStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RunningStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunningStatistics* internal_default_instance() {
    return reinterpret_cast<const RunningStatistics*>(
               &_RunningStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RunningStatistics& a, RunningStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningStatistics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunningStatistics* New() const final {
    return CreateMaybeMessage<RunningStatistics>(nullptr);
  }

  RunningStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunningStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RunningStatistics& from);
  void MergeFrom(const RunningStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunningStatistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.RunningStatistics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxFieldNumber = 2,
    kMeanlogsFieldNumber = 3,
    kMeanFieldNumber = 4,
    kMinFieldNumber = 5,
    kSumFieldNumber = 6,
    kVarianceFieldNumber = 7,
    kCountFieldNumber = 1,
  };
  // double max = 2;
  void clear_max();
  double max() const;
  void set_max(double value);

  // double meanlogs = 3;
  void clear_meanlogs();
  double meanlogs() const;
  void set_meanlogs(double value);

  // double mean = 4;
  void clear_mean();
  double mean() const;
  void set_mean(double value);

  // double min = 5;
  void clear_min();
  double min() const;
  void set_min(double value);

  // double sum = 6;
  void clear_sum();
  double sum() const;
  void set_sum(double value);

  // double variance = 7;
  void clear_variance();
  double variance() const;
  void set_variance(double value);

  // int32 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RunningStatistics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  double max_;
  double meanlogs_;
  double mean_;
  double min_;
  double sum_;
  double variance_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Bin :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Bin) */ {
 public:
  Bin();
  virtual ~Bin();

  Bin(const Bin& from);
  Bin(Bin&& from) noexcept
    : Bin() {
    *this = ::std::move(from);
  }

  inline Bin& operator=(const Bin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bin& operator=(Bin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Bin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bin* internal_default_instance() {
    return reinterpret_cast<const Bin*>(
               &_Bin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Bin& a, Bin& b) {
    a.Swap(&b);
  }
  inline void Swap(Bin* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bin* New() const final {
    return CreateMaybeMessage<Bin>(nullptr);
  }

  Bin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Bin& from);
  void MergeFrom(const Bin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Bin";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticMapsFieldNumber = 2,
    kBinCountFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
  int diagnostic_maps_size() const;
  void clear_diagnostic_maps();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_diagnostic_maps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
      mutable_diagnostic_maps();
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostic_maps(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* add_diagnostic_maps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
      diagnostic_maps() const;

  // int32 bin_count = 1;
  void clear_bin_count();
  ::PROTOBUF_NAMESPACE_ID::int32 bin_count() const;
  void set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Bin)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > diagnostic_maps_;
  ::PROTOBUF_NAMESPACE_ID::int32 bin_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class SummaryOptions :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.SummaryOptions) */ {
 public:
  SummaryOptions();
  virtual ~SummaryOptions();

  SummaryOptions(const SummaryOptions& from);
  SummaryOptions(SummaryOptions&& from) noexcept
    : SummaryOptions() {
    *this = ::std::move(from);
  }

  inline SummaryOptions& operator=(const SummaryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummaryOptions& operator=(SummaryOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SummaryOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SummaryOptions* internal_default_instance() {
    return reinterpret_cast<const SummaryOptions*>(
               &_SummaryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SummaryOptions& a, SummaryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SummaryOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SummaryOptions* New() const final {
    return CreateMaybeMessage<SummaryOptions>(nullptr);
  }

  SummaryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SummaryOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SummaryOptions& from);
  void MergeFrom(const SummaryOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SummaryOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.SummaryOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 9,
    kAvgFieldNumber = 1,
    kGeometricMeanFieldNumber = 2,
    kStdFieldNumber = 3,
    kCountFieldNumber = 4,
    kSumFieldNumber = 5,
    kMinFieldNumber = 6,
    kMaxFieldNumber = 7,
    kNansFieldNumber = 8,
  };
  // repeated float percentile = 9;
  int percentile_size() const;
  void clear_percentile();
  float percentile(int index) const;
  void set_percentile(int index, float value);
  void add_percentile(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      percentile() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_percentile();

  // bool avg = 1;
  void clear_avg();
  bool avg() const;
  void set_avg(bool value);

  // bool geometric_mean = 2;
  void clear_geometric_mean();
  bool geometric_mean() const;
  void set_geometric_mean(bool value);

  // bool std = 3;
  void clear_std();
  bool std() const;
  void set_std(bool value);

  // bool count = 4;
  void clear_count();
  bool count() const;
  void set_count(bool value);

  // bool sum = 5;
  void clear_sum();
  bool sum() const;
  void set_sum(bool value);

  // bool min = 6;
  void clear_min();
  bool min() const;
  void set_min(bool value);

  // bool max = 7;
  void clear_max();
  bool max() const;
  void set_max(bool value);

  // bool nans = 8;
  void clear_nans();
  bool nans() const;
  void set_nans(bool value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.SummaryOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > percentile_;
  mutable std::atomic<int> _percentile_cached_byte_size_;
  bool avg_;
  bool geometric_mean_;
  bool std_;
  bool count_;
  bool sum_;
  bool min_;
  bool max_;
  bool nans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class Histogram_AllBinsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Histogram_AllBinsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Histogram_AllBinsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Histogram_AllBinsEntry_DoNotUse();
  Histogram_AllBinsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Histogram_AllBinsEntry_DoNotUse& other);
  static const Histogram_AllBinsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Histogram_AllBinsEntry_DoNotUse*>(&_Histogram_AllBinsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Histogram :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Histogram) */ {
 public:
  Histogram();
  virtual ~Histogram();

  Histogram(const Histogram& from);
  Histogram(Histogram&& from) noexcept
    : Histogram() {
    *this = ::std::move(from);
  }

  inline Histogram& operator=(const Histogram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Histogram& operator=(Histogram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Histogram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Histogram* internal_default_instance() {
    return reinterpret_cast<const Histogram*>(
               &_Histogram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Histogram& a, Histogram& b) {
    a.Swap(&b);
  }
  inline void Swap(Histogram* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Histogram* New() const final {
    return CreateMaybeMessage<Histogram>(nullptr);
  }

  Histogram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Histogram>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Histogram& from);
  void MergeFrom(const Histogram& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Histogram* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.Histogram";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSampleValuesFieldNumber = 6,
    kNanDiagnosticsFieldNumber = 9,
    kAllBinsFieldNumber = 11,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kUnitFieldNumber = 2,
    kBinBoundariesFieldNumber = 3,
    kDiagnosticsFieldNumber = 5,
    kRunningFieldNumber = 10,
    kSummaryOptionsFieldNumber = 12,
    kMaxNumSampleValuesFieldNumber = 7,
    kNumNansFieldNumber = 8,
  };
  // repeated double sample_values = 6;
  int sample_values_size() const;
  void clear_sample_values();
  double sample_values(int index) const;
  void set_sample_values(int index, double value);
  void add_sample_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      sample_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_sample_values();

  // repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
  int nan_diagnostics_size() const;
  void clear_nan_diagnostics();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_nan_diagnostics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
      mutable_nan_diagnostics();
  const ::catapult::tracing::tracing::proto::DiagnosticMap& nan_diagnostics(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* add_nan_diagnostics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
      nan_diagnostics() const;

  // map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
  int all_bins_size() const;
  void clear_all_bins();
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
      all_bins() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
      mutable_all_bins();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
  bool has_unit() const;
  void clear_unit();
  const ::catapult::tracing::tracing::proto::UnitAndDirection& unit() const;
  ::catapult::tracing::tracing::proto::UnitAndDirection* release_unit();
  ::catapult::tracing::tracing::proto::UnitAndDirection* mutable_unit();
  void set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* unit);

  // .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
  bool has_bin_boundaries() const;
  void clear_bin_boundaries();
  const ::catapult::tracing::tracing::proto::BinBoundaries& bin_boundaries() const;
  ::catapult::tracing::tracing::proto::BinBoundaries* release_bin_boundaries();
  ::catapult::tracing::tracing::proto::BinBoundaries* mutable_bin_boundaries();
  void set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries);

  // .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
  bool has_diagnostics() const;
  void clear_diagnostics();
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostics() const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* release_diagnostics();
  ::catapult::tracing::tracing::proto::DiagnosticMap* mutable_diagnostics();
  void set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics);

  // .catapult.tracing.tracing.proto.RunningStatistics running = 10;
  bool has_running() const;
  void clear_running();
  const ::catapult::tracing::tracing::proto::RunningStatistics& running() const;
  ::catapult::tracing::tracing::proto::RunningStatistics* release_running();
  ::catapult::tracing::tracing::proto::RunningStatistics* mutable_running();
  void set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* running);

  // .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
  bool has_summary_options() const;
  void clear_summary_options();
  const ::catapult::tracing::tracing::proto::SummaryOptions& summary_options() const;
  ::catapult::tracing::tracing::proto::SummaryOptions* release_summary_options();
  ::catapult::tracing::tracing::proto::SummaryOptions* mutable_summary_options();
  void set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* summary_options);

  // int32 max_num_sample_values = 7;
  void clear_max_num_sample_values();
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_sample_values() const;
  void set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 num_nans = 8;
  void clear_num_nans();
  ::PROTOBUF_NAMESPACE_ID::int32 num_nans() const;
  void set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Histogram)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > sample_values_;
  mutable std::atomic<int> _sample_values_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > nan_diagnostics_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Histogram_AllBinsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > all_bins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::catapult::tracing::tracing::proto::UnitAndDirection* unit_;
  ::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries_;
  ::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics_;
  ::catapult::tracing::tracing::proto::RunningStatistics* running_;
  ::catapult::tracing::tracing::proto::SummaryOptions* summary_options_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_sample_values_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_nans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// -------------------------------------------------------------------

class HistogramSet_SharedDiagnosticsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<HistogramSet_SharedDiagnosticsEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<HistogramSet_SharedDiagnosticsEntry_DoNotUse, 
    std::string, ::catapult::tracing::tracing::proto::Diagnostic,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  HistogramSet_SharedDiagnosticsEntry_DoNotUse();
  HistogramSet_SharedDiagnosticsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HistogramSet_SharedDiagnosticsEntry_DoNotUse& other);
  static const HistogramSet_SharedDiagnosticsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HistogramSet_SharedDiagnosticsEntry_DoNotUse*>(&_HistogramSet_SharedDiagnosticsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "catapult.tracing.tracing.proto.HistogramSet.SharedDiagnosticsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class HistogramSet :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.HistogramSet) */ {
 public:
  HistogramSet();
  virtual ~HistogramSet();

  HistogramSet(const HistogramSet& from);
  HistogramSet(HistogramSet&& from) noexcept
    : HistogramSet() {
    *this = ::std::move(from);
  }

  inline HistogramSet& operator=(const HistogramSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramSet& operator=(HistogramSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const HistogramSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistogramSet* internal_default_instance() {
    return reinterpret_cast<const HistogramSet*>(
               &_HistogramSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HistogramSet& a, HistogramSet& b) {
    a.Swap(&b);
  }
  inline void Swap(HistogramSet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistogramSet* New() const final {
    return CreateMaybeMessage<HistogramSet>(nullptr);
  }

  HistogramSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistogramSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HistogramSet& from);
  void MergeFrom(const HistogramSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "catapult.tracing.tracing.proto.HistogramSet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHistogramsFieldNumber = 1,
    kSharedDiagnosticsFieldNumber = 2,
  };
  // repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
  int histograms_size() const;
  void clear_histograms();
  ::catapult::tracing::tracing::proto::Histogram* mutable_histograms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >*
      mutable_histograms();
  const ::catapult::tracing::tracing::proto::Histogram& histograms(int index) const;
  ::catapult::tracing::tracing::proto::Histogram* add_histograms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >&
      histograms() const;

  // map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
  int shared_diagnostics_size() const;
  void clear_shared_diagnostics();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
      shared_diagnostics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
      mutable_shared_diagnostics();

  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.HistogramSet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram > histograms_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      HistogramSet_SharedDiagnosticsEntry_DoNotUse,
      std::string, ::catapult::tracing::tracing::proto::Diagnostic,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > shared_diagnostics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_histogram_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UnitAndDirection

// .catapult.tracing.tracing.proto.Unit unit = 1;
inline void UnitAndDirection::clear_unit() {
  unit_ = 0;
}
inline ::catapult::tracing::tracing::proto::Unit UnitAndDirection::unit() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.unit)
  return static_cast< ::catapult::tracing::tracing::proto::Unit >(unit_);
}
inline void UnitAndDirection::set_unit(::catapult::tracing::tracing::proto::Unit value) {
  
  unit_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.unit)
}

// .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
inline void UnitAndDirection::clear_improvement_direction() {
  improvement_direction_ = 0;
}
inline ::catapult::tracing::tracing::proto::ImprovementDirection UnitAndDirection::improvement_direction() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
  return static_cast< ::catapult::tracing::tracing::proto::ImprovementDirection >(improvement_direction_);
}
inline void UnitAndDirection::set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value) {
  
  improvement_direction_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
}

// -------------------------------------------------------------------

// BinBoundaryDetailedSpec

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
inline void BinBoundaryDetailedSpec::clear_boundary_type() {
  boundary_type_ = 0;
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec::boundary_type() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
  return static_cast< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type >(boundary_type_);
}
inline void BinBoundaryDetailedSpec::set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value) {
  
  boundary_type_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
}

// double maximum_bin_boundary = 2;
inline void BinBoundaryDetailedSpec::clear_maximum_bin_boundary() {
  maximum_bin_boundary_ = 0;
}
inline double BinBoundaryDetailedSpec::maximum_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
  return maximum_bin_boundary_;
}
inline void BinBoundaryDetailedSpec::set_maximum_bin_boundary(double value) {
  
  maximum_bin_boundary_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
}

// int32 num_bin_boundaries = 3;
inline void BinBoundaryDetailedSpec::clear_num_bin_boundaries() {
  num_bin_boundaries_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BinBoundaryDetailedSpec::num_bin_boundaries() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
  return num_bin_boundaries_;
}
inline void BinBoundaryDetailedSpec::set_num_bin_boundaries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_bin_boundaries_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
}

// -------------------------------------------------------------------

// BinBoundarySpec

// double bin_boundary = 1;
inline bool BinBoundarySpec::has_bin_boundary() const {
  return boundary_oneof_case() == kBinBoundary;
}
inline void BinBoundarySpec::set_has_bin_boundary() {
  _oneof_case_[0] = kBinBoundary;
}
inline void BinBoundarySpec::clear_bin_boundary() {
  if (has_bin_boundary()) {
    boundary_oneof_.bin_boundary_ = 0;
    clear_has_boundary_oneof();
  }
}
inline double BinBoundarySpec::bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
  if (has_bin_boundary()) {
    return boundary_oneof_.bin_boundary_;
  }
  return 0;
}
inline void BinBoundarySpec::set_bin_boundary(double value) {
  if (!has_bin_boundary()) {
    clear_boundary_oneof();
    set_has_bin_boundary();
  }
  boundary_oneof_.bin_boundary_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
}

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
inline bool BinBoundarySpec::has_bin_spec() const {
  return boundary_oneof_case() == kBinSpec;
}
inline void BinBoundarySpec::set_has_bin_spec() {
  _oneof_case_[0] = kBinSpec;
}
inline void BinBoundarySpec::clear_bin_spec() {
  if (has_bin_spec()) {
    delete boundary_oneof_.bin_spec_;
    clear_has_boundary_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::release_bin_spec() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  if (has_bin_spec()) {
    clear_has_boundary_oneof();
      ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* temp = boundary_oneof_.bin_spec_;
    boundary_oneof_.bin_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& BinBoundarySpec::bin_spec() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return has_bin_spec()
      ? *boundary_oneof_.bin_spec_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec*>(&::catapult::tracing::tracing::proto::_BinBoundaryDetailedSpec_default_instance_);
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* BinBoundarySpec::mutable_bin_spec() {
  if (!has_bin_spec()) {
    clear_boundary_oneof();
    set_has_bin_spec();
    boundary_oneof_.bin_spec_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return boundary_oneof_.bin_spec_;
}

inline bool BinBoundarySpec::has_boundary_oneof() const {
  return boundary_oneof_case() != BOUNDARY_ONEOF_NOT_SET;
}
inline void BinBoundarySpec::clear_has_boundary_oneof() {
  _oneof_case_[0] = BOUNDARY_ONEOF_NOT_SET;
}
inline BinBoundarySpec::BoundaryOneofCase BinBoundarySpec::boundary_oneof_case() const {
  return BinBoundarySpec::BoundaryOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinBoundaries

// double first_bin_boundary = 1;
inline void BinBoundaries::clear_first_bin_boundary() {
  first_bin_boundary_ = 0;
}
inline double BinBoundaries::first_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
  return first_bin_boundary_;
}
inline void BinBoundaries::set_first_bin_boundary(double value) {
  
  first_bin_boundary_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
}

// repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
inline int BinBoundaries::bin_specs_size() const {
  return bin_specs_.size();
}
inline void BinBoundaries::clear_bin_specs() {
  bin_specs_.Clear();
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* BinBoundaries::mutable_bin_specs(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >*
BinBoundaries::mutable_bin_specs() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return &bin_specs_;
}
inline const ::catapult::tracing::tracing::proto::BinBoundarySpec& BinBoundaries::bin_specs(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_.Get(index);
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* BinBoundaries::add_bin_specs() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec >&
BinBoundaries::bin_specs() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return bin_specs_;
}

// -------------------------------------------------------------------

// Breakdown

// -------------------------------------------------------------------

// DateRange

// -------------------------------------------------------------------

// GenericSet

// repeated string values = 1;
inline int GenericSet::values_size() const {
  return values_.size();
}
inline void GenericSet::clear_values() {
  values_.Clear();
}
inline const std::string& GenericSet::values(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.GenericSet.values)
  return values_.Get(index);
}
inline std::string* GenericSet::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return values_.Mutable(index);
}
inline void GenericSet::set_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.GenericSet.values)
  values_.Mutable(index)->assign(value);
}
inline void GenericSet::set_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.GenericSet.values)
  values_.Mutable(index)->assign(std::move(value));
}
inline void GenericSet::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.GenericSet.values)
}
inline std::string* GenericSet::add_values() {
  // @@protoc_insertion_point(field_add_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return values_.Add();
}
inline void GenericSet::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:catapult.tracing.tracing.proto.GenericSet.values)
}
inline void GenericSet::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:catapult.tracing.tracing.proto.GenericSet.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenericSet::values() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.GenericSet.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenericSet::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.GenericSet.values)
  return &values_;
}

// -------------------------------------------------------------------

// RelatedEventSet

// -------------------------------------------------------------------

// RelatedNameMap

// -------------------------------------------------------------------

// Scalar

// -------------------------------------------------------------------

// Diagnostic

// .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
inline bool Diagnostic::has_breakdown() const {
  return diagnostic_oneof_case() == kBreakdown;
}
inline void Diagnostic::set_has_breakdown() {
  _oneof_case_[0] = kBreakdown;
}
inline void Diagnostic::clear_breakdown() {
  if (has_breakdown()) {
    delete diagnostic_oneof_.breakdown_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::release_breakdown() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  if (has_breakdown()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::Breakdown* temp = diagnostic_oneof_.breakdown_;
    diagnostic_oneof_.breakdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Breakdown& Diagnostic::breakdown() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return has_breakdown()
      ? *diagnostic_oneof_.breakdown_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::Breakdown*>(&::catapult::tracing::tracing::proto::_Breakdown_default_instance_);
}
inline ::catapult::tracing::tracing::proto::Breakdown* Diagnostic::mutable_breakdown() {
  if (!has_breakdown()) {
    clear_diagnostic_oneof();
    set_has_breakdown();
    diagnostic_oneof_.breakdown_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::Breakdown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return diagnostic_oneof_.breakdown_;
}

// .catapult.tracing.tracing.proto.DateRange date_range = 2;
inline bool Diagnostic::has_date_range() const {
  return diagnostic_oneof_case() == kDateRange;
}
inline void Diagnostic::set_has_date_range() {
  _oneof_case_[0] = kDateRange;
}
inline void Diagnostic::clear_date_range() {
  if (has_date_range()) {
    delete diagnostic_oneof_.date_range_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::release_date_range() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.date_range)
  if (has_date_range()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::DateRange* temp = diagnostic_oneof_.date_range_;
    diagnostic_oneof_.date_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::DateRange& Diagnostic::date_range() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return has_date_range()
      ? *diagnostic_oneof_.date_range_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::DateRange*>(&::catapult::tracing::tracing::proto::_DateRange_default_instance_);
}
inline ::catapult::tracing::tracing::proto::DateRange* Diagnostic::mutable_date_range() {
  if (!has_date_range()) {
    clear_diagnostic_oneof();
    set_has_date_range();
    diagnostic_oneof_.date_range_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::DateRange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return diagnostic_oneof_.date_range_;
}

// .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
inline bool Diagnostic::has_generic_set() const {
  return diagnostic_oneof_case() == kGenericSet;
}
inline void Diagnostic::set_has_generic_set() {
  _oneof_case_[0] = kGenericSet;
}
inline void Diagnostic::clear_generic_set() {
  if (has_generic_set()) {
    delete diagnostic_oneof_.generic_set_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::release_generic_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  if (has_generic_set()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::GenericSet* temp = diagnostic_oneof_.generic_set_;
    diagnostic_oneof_.generic_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::GenericSet& Diagnostic::generic_set() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return has_generic_set()
      ? *diagnostic_oneof_.generic_set_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::GenericSet*>(&::catapult::tracing::tracing::proto::_GenericSet_default_instance_);
}
inline ::catapult::tracing::tracing::proto::GenericSet* Diagnostic::mutable_generic_set() {
  if (!has_generic_set()) {
    clear_diagnostic_oneof();
    set_has_generic_set();
    diagnostic_oneof_.generic_set_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::GenericSet >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return diagnostic_oneof_.generic_set_;
}

// .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
inline bool Diagnostic::has_related_event_set() const {
  return diagnostic_oneof_case() == kRelatedEventSet;
}
inline void Diagnostic::set_has_related_event_set() {
  _oneof_case_[0] = kRelatedEventSet;
}
inline void Diagnostic::clear_related_event_set() {
  if (has_related_event_set()) {
    delete diagnostic_oneof_.related_event_set_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::release_related_event_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  if (has_related_event_set()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::RelatedEventSet* temp = diagnostic_oneof_.related_event_set_;
    diagnostic_oneof_.related_event_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedEventSet& Diagnostic::related_event_set() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return has_related_event_set()
      ? *diagnostic_oneof_.related_event_set_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::RelatedEventSet*>(&::catapult::tracing::tracing::proto::_RelatedEventSet_default_instance_);
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* Diagnostic::mutable_related_event_set() {
  if (!has_related_event_set()) {
    clear_diagnostic_oneof();
    set_has_related_event_set();
    diagnostic_oneof_.related_event_set_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::RelatedEventSet >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return diagnostic_oneof_.related_event_set_;
}

// .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
inline bool Diagnostic::has_related_name_map() const {
  return diagnostic_oneof_case() == kRelatedNameMap;
}
inline void Diagnostic::set_has_related_name_map() {
  _oneof_case_[0] = kRelatedNameMap;
}
inline void Diagnostic::clear_related_name_map() {
  if (has_related_name_map()) {
    delete diagnostic_oneof_.related_name_map_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::release_related_name_map() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  if (has_related_name_map()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::RelatedNameMap* temp = diagnostic_oneof_.related_name_map_;
    diagnostic_oneof_.related_name_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedNameMap& Diagnostic::related_name_map() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return has_related_name_map()
      ? *diagnostic_oneof_.related_name_map_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::RelatedNameMap*>(&::catapult::tracing::tracing::proto::_RelatedNameMap_default_instance_);
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* Diagnostic::mutable_related_name_map() {
  if (!has_related_name_map()) {
    clear_diagnostic_oneof();
    set_has_related_name_map();
    diagnostic_oneof_.related_name_map_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::RelatedNameMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return diagnostic_oneof_.related_name_map_;
}

// .catapult.tracing.tracing.proto.Scalar scalar = 6;
inline bool Diagnostic::has_scalar() const {
  return diagnostic_oneof_case() == kScalar;
}
inline void Diagnostic::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Diagnostic::clear_scalar() {
  if (has_scalar()) {
    delete diagnostic_oneof_.scalar_;
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::release_scalar() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.scalar)
  if (has_scalar()) {
    clear_has_diagnostic_oneof();
      ::catapult::tracing::tracing::proto::Scalar* temp = diagnostic_oneof_.scalar_;
    diagnostic_oneof_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Scalar& Diagnostic::scalar() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return has_scalar()
      ? *diagnostic_oneof_.scalar_
      : *reinterpret_cast< ::catapult::tracing::tracing::proto::Scalar*>(&::catapult::tracing::tracing::proto::_Scalar_default_instance_);
}
inline ::catapult::tracing::tracing::proto::Scalar* Diagnostic::mutable_scalar() {
  if (!has_scalar()) {
    clear_diagnostic_oneof();
    set_has_scalar();
    diagnostic_oneof_.scalar_ = CreateMaybeMessage< ::catapult::tracing::tracing::proto::Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return diagnostic_oneof_.scalar_;
}

// string shared_diagnostic_guid = 7;
inline bool Diagnostic::has_shared_diagnostic_guid() const {
  return diagnostic_oneof_case() == kSharedDiagnosticGuid;
}
inline void Diagnostic::set_has_shared_diagnostic_guid() {
  _oneof_case_[0] = kSharedDiagnosticGuid;
}
inline void Diagnostic::clear_shared_diagnostic_guid() {
  if (has_shared_diagnostic_guid()) {
    diagnostic_oneof_.shared_diagnostic_guid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_diagnostic_oneof();
  }
}
inline const std::string& Diagnostic::shared_diagnostic_guid() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (has_shared_diagnostic_guid()) {
    return diagnostic_oneof_.shared_diagnostic_guid_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Diagnostic::set_shared_diagnostic_guid(const std::string& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (!has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline void Diagnostic::set_shared_diagnostic_guid(std::string&& value) {
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (!has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline void Diagnostic::set_shared_diagnostic_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline void Diagnostic::set_shared_diagnostic_guid(const char* value, size_t size) {
  if (!has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  diagnostic_oneof_.shared_diagnostic_guid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline std::string* Diagnostic::mutable_shared_diagnostic_guid() {
  if (!has_shared_diagnostic_guid()) {
    clear_diagnostic_oneof();
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  return diagnostic_oneof_.shared_diagnostic_guid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Diagnostic::release_shared_diagnostic_guid() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (has_shared_diagnostic_guid()) {
    clear_has_diagnostic_oneof();
    return diagnostic_oneof_.shared_diagnostic_guid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Diagnostic::set_allocated_shared_diagnostic_guid(std::string* shared_diagnostic_guid) {
  if (has_diagnostic_oneof()) {
    clear_diagnostic_oneof();
  }
  if (shared_diagnostic_guid != nullptr) {
    set_has_shared_diagnostic_guid();
    diagnostic_oneof_.shared_diagnostic_guid_.UnsafeSetDefault(shared_diagnostic_guid);
  }
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}

inline bool Diagnostic::has_diagnostic_oneof() const {
  return diagnostic_oneof_case() != DIAGNOSTIC_ONEOF_NOT_SET;
}
inline void Diagnostic::clear_has_diagnostic_oneof() {
  _oneof_case_[0] = DIAGNOSTIC_ONEOF_NOT_SET;
}
inline Diagnostic::DiagnosticOneofCase Diagnostic::diagnostic_oneof_case() const {
  return Diagnostic::DiagnosticOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DiagnosticMap

// map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
inline int DiagnosticMap::diagnostic_map_size() const {
  return diagnostic_map_.size();
}
inline void DiagnosticMap::clear_diagnostic_map() {
  diagnostic_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
DiagnosticMap::diagnostic_map() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return diagnostic_map_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
DiagnosticMap::mutable_diagnostic_map() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return diagnostic_map_.MutableMap();
}

// -------------------------------------------------------------------

// RunningStatistics

// int32 count = 1;
inline void RunningStatistics::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RunningStatistics::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.count)
  return count_;
}
inline void RunningStatistics::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.count)
}

// double max = 2;
inline void RunningStatistics::clear_max() {
  max_ = 0;
}
inline double RunningStatistics::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.max)
  return max_;
}
inline void RunningStatistics::set_max(double value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.max)
}

// double meanlogs = 3;
inline void RunningStatistics::clear_meanlogs() {
  meanlogs_ = 0;
}
inline double RunningStatistics::meanlogs() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
  return meanlogs_;
}
inline void RunningStatistics::set_meanlogs(double value) {
  
  meanlogs_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
}

// double mean = 4;
inline void RunningStatistics::clear_mean() {
  mean_ = 0;
}
inline double RunningStatistics::mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.mean)
  return mean_;
}
inline void RunningStatistics::set_mean(double value) {
  
  mean_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.mean)
}

// double min = 5;
inline void RunningStatistics::clear_min() {
  min_ = 0;
}
inline double RunningStatistics::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.min)
  return min_;
}
inline void RunningStatistics::set_min(double value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.min)
}

// double sum = 6;
inline void RunningStatistics::clear_sum() {
  sum_ = 0;
}
inline double RunningStatistics::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.sum)
  return sum_;
}
inline void RunningStatistics::set_sum(double value) {
  
  sum_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.sum)
}

// double variance = 7;
inline void RunningStatistics::clear_variance() {
  variance_ = 0;
}
inline double RunningStatistics::variance() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.variance)
  return variance_;
}
inline void RunningStatistics::set_variance(double value) {
  
  variance_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.variance)
}

// -------------------------------------------------------------------

// Bin

// int32 bin_count = 1;
inline void Bin::clear_bin_count() {
  bin_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bin::bin_count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.bin_count)
  return bin_count_;
}
inline void Bin::set_bin_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bin_count_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Bin.bin_count)
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
inline int Bin::diagnostic_maps_size() const {
  return diagnostic_maps_.size();
}
inline void Bin::clear_diagnostic_maps() {
  diagnostic_maps_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Bin::mutable_diagnostic_maps(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
Bin::mutable_diagnostic_maps() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return &diagnostic_maps_;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Bin::diagnostic_maps(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_.Get(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Bin::add_diagnostic_maps() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
Bin::diagnostic_maps() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return diagnostic_maps_;
}

// -------------------------------------------------------------------

// SummaryOptions

// bool avg = 1;
inline void SummaryOptions::clear_avg() {
  avg_ = false;
}
inline bool SummaryOptions::avg() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.avg)
  return avg_;
}
inline void SummaryOptions::set_avg(bool value) {
  
  avg_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.avg)
}

// bool geometric_mean = 2;
inline void SummaryOptions::clear_geometric_mean() {
  geometric_mean_ = false;
}
inline bool SummaryOptions::geometric_mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
  return geometric_mean_;
}
inline void SummaryOptions::set_geometric_mean(bool value) {
  
  geometric_mean_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
}

// bool std = 3;
inline void SummaryOptions::clear_std() {
  std_ = false;
}
inline bool SummaryOptions::std() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.std)
  return std_;
}
inline void SummaryOptions::set_std(bool value) {
  
  std_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.std)
}

// bool count = 4;
inline void SummaryOptions::clear_count() {
  count_ = false;
}
inline bool SummaryOptions::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.count)
  return count_;
}
inline void SummaryOptions::set_count(bool value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.count)
}

// bool sum = 5;
inline void SummaryOptions::clear_sum() {
  sum_ = false;
}
inline bool SummaryOptions::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.sum)
  return sum_;
}
inline void SummaryOptions::set_sum(bool value) {
  
  sum_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.sum)
}

// bool min = 6;
inline void SummaryOptions::clear_min() {
  min_ = false;
}
inline bool SummaryOptions::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.min)
  return min_;
}
inline void SummaryOptions::set_min(bool value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.min)
}

// bool max = 7;
inline void SummaryOptions::clear_max() {
  max_ = false;
}
inline bool SummaryOptions::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.max)
  return max_;
}
inline void SummaryOptions::set_max(bool value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.max)
}

// bool nans = 8;
inline void SummaryOptions::clear_nans() {
  nans_ = false;
}
inline bool SummaryOptions::nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.nans)
  return nans_;
}
inline void SummaryOptions::set_nans(bool value) {
  
  nans_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.nans)
}

// repeated float percentile = 9;
inline int SummaryOptions::percentile_size() const {
  return percentile_.size();
}
inline void SummaryOptions::clear_percentile() {
  percentile_.Clear();
}
inline float SummaryOptions::percentile(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return percentile_.Get(index);
}
inline void SummaryOptions::set_percentile(int index, float value) {
  percentile_.Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline void SummaryOptions::add_percentile(float value) {
  percentile_.Add(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SummaryOptions::percentile() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return percentile_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SummaryOptions::mutable_percentile() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return &percentile_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Histogram

// string name = 1;
inline void Histogram::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Histogram::name() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.name)
  return name_.GetNoArena();
}
inline void Histogram::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.name)
}
inline void Histogram::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Histogram.name)
}
inline void Histogram::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Histogram.name)
}
inline void Histogram::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Histogram.name)
}
inline std::string* Histogram::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Histogram::release_name() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Histogram::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.name)
}

// .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
inline bool Histogram::has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline void Histogram::clear_unit() {
  if (GetArenaNoVirtual() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::UnitAndDirection& Histogram::unit() const {
  const ::catapult::tracing::tracing::proto::UnitAndDirection* p = unit_;
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.unit)
  return p != nullptr ? *p : *reinterpret_cast<const ::catapult::tracing::tracing::proto::UnitAndDirection*>(
      &::catapult::tracing::tracing::proto::_UnitAndDirection_default_instance_);
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::release_unit() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.unit)
  
  ::catapult::tracing::tracing::proto::UnitAndDirection* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* Histogram::mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::UnitAndDirection>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.unit)
  return unit_;
}
inline void Histogram::set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.unit)
}

// .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
inline bool Histogram::has_bin_boundaries() const {
  return this != internal_default_instance() && bin_boundaries_ != nullptr;
}
inline void Histogram::clear_bin_boundaries() {
  if (GetArenaNoVirtual() == nullptr && bin_boundaries_ != nullptr) {
    delete bin_boundaries_;
  }
  bin_boundaries_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::BinBoundaries& Histogram::bin_boundaries() const {
  const ::catapult::tracing::tracing::proto::BinBoundaries* p = bin_boundaries_;
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return p != nullptr ? *p : *reinterpret_cast<const ::catapult::tracing::tracing::proto::BinBoundaries*>(
      &::catapult::tracing::tracing::proto::_BinBoundaries_default_instance_);
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::release_bin_boundaries() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  
  ::catapult::tracing::tracing::proto::BinBoundaries* temp = bin_boundaries_;
  bin_boundaries_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* Histogram::mutable_bin_boundaries() {
  
  if (bin_boundaries_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::BinBoundaries>(GetArenaNoVirtual());
    bin_boundaries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return bin_boundaries_;
}
inline void Histogram::set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* bin_boundaries) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bin_boundaries_;
  }
  if (bin_boundaries) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bin_boundaries = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin_boundaries, submessage_arena);
    }
    
  } else {
    
  }
  bin_boundaries_ = bin_boundaries;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
}

// string description = 4;
inline void Histogram::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Histogram::description() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.description)
  return description_.GetNoArena();
}
inline void Histogram::set_description(const std::string& value) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.description)
}
inline void Histogram::set_description(std::string&& value) {
  
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:catapult.tracing.tracing.proto.Histogram.description)
}
inline void Histogram::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:catapult.tracing.tracing.proto.Histogram.description)
}
inline void Histogram::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:catapult.tracing.tracing.proto.Histogram.description)
}
inline std::string* Histogram::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Histogram::release_description() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.description)
  
  return description_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Histogram::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.description)
}

// .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
inline bool Histogram::has_diagnostics() const {
  return this != internal_default_instance() && diagnostics_ != nullptr;
}
inline void Histogram::clear_diagnostics() {
  if (GetArenaNoVirtual() == nullptr && diagnostics_ != nullptr) {
    delete diagnostics_;
  }
  diagnostics_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::diagnostics() const {
  const ::catapult::tracing::tracing::proto::DiagnosticMap* p = diagnostics_;
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return p != nullptr ? *p : *reinterpret_cast<const ::catapult::tracing::tracing::proto::DiagnosticMap*>(
      &::catapult::tracing::tracing::proto::_DiagnosticMap_default_instance_);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::release_diagnostics() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.diagnostics)
  
  ::catapult::tracing::tracing::proto::DiagnosticMap* temp = diagnostics_;
  diagnostics_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::mutable_diagnostics() {
  
  if (diagnostics_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::DiagnosticMap>(GetArenaNoVirtual());
    diagnostics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return diagnostics_;
}
inline void Histogram::set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* diagnostics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete diagnostics_;
  }
  if (diagnostics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      diagnostics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diagnostics, submessage_arena);
    }
    
  } else {
    
  }
  diagnostics_ = diagnostics;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.diagnostics)
}

// repeated double sample_values = 6;
inline int Histogram::sample_values_size() const {
  return sample_values_.size();
}
inline void Histogram::clear_sample_values() {
  sample_values_.Clear();
}
inline double Histogram::sample_values(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.sample_values)
  return sample_values_.Get(index);
}
inline void Histogram::set_sample_values(int index, double value) {
  sample_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline void Histogram::add_sample_values(double value) {
  sample_values_.Add(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Histogram::sample_values() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  return sample_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Histogram::mutable_sample_values() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  return &sample_values_;
}

// int32 max_num_sample_values = 7;
inline void Histogram::clear_max_num_sample_values() {
  max_num_sample_values_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::max_num_sample_values() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
  return max_num_sample_values_;
}
inline void Histogram::set_max_num_sample_values(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_num_sample_values_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
}

// int32 num_nans = 8;
inline void Histogram::clear_num_nans() {
  num_nans_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Histogram::num_nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.num_nans)
  return num_nans_;
}
inline void Histogram::set_num_nans(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_nans_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.num_nans)
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
inline int Histogram::nan_diagnostics_size() const {
  return nan_diagnostics_.size();
}
inline void Histogram::clear_nan_diagnostics() {
  nan_diagnostics_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::mutable_nan_diagnostics(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >*
Histogram::mutable_nan_diagnostics() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return &nan_diagnostics_;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::nan_diagnostics(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_.Get(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* Histogram::add_nan_diagnostics() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap >&
Histogram::nan_diagnostics() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return nan_diagnostics_;
}

// .catapult.tracing.tracing.proto.RunningStatistics running = 10;
inline bool Histogram::has_running() const {
  return this != internal_default_instance() && running_ != nullptr;
}
inline void Histogram::clear_running() {
  if (GetArenaNoVirtual() == nullptr && running_ != nullptr) {
    delete running_;
  }
  running_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::RunningStatistics& Histogram::running() const {
  const ::catapult::tracing::tracing::proto::RunningStatistics* p = running_;
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.running)
  return p != nullptr ? *p : *reinterpret_cast<const ::catapult::tracing::tracing::proto::RunningStatistics*>(
      &::catapult::tracing::tracing::proto::_RunningStatistics_default_instance_);
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::release_running() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.running)
  
  ::catapult::tracing::tracing::proto::RunningStatistics* temp = running_;
  running_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* Histogram::mutable_running() {
  
  if (running_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::RunningStatistics>(GetArenaNoVirtual());
    running_ = p;
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.running)
  return running_;
}
inline void Histogram::set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* running) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete running_;
  }
  if (running) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      running = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, running, submessage_arena);
    }
    
  } else {
    
  }
  running_ = running;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.running)
}

// map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
inline int Histogram::all_bins_size() const {
  return all_bins_.size();
}
inline void Histogram::clear_all_bins() {
  all_bins_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >&
Histogram::all_bins() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return all_bins_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::catapult::tracing::tracing::proto::Bin >*
Histogram::mutable_all_bins() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return all_bins_.MutableMap();
}

// .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
inline bool Histogram::has_summary_options() const {
  return this != internal_default_instance() && summary_options_ != nullptr;
}
inline void Histogram::clear_summary_options() {
  if (GetArenaNoVirtual() == nullptr && summary_options_ != nullptr) {
    delete summary_options_;
  }
  summary_options_ = nullptr;
}
inline const ::catapult::tracing::tracing::proto::SummaryOptions& Histogram::summary_options() const {
  const ::catapult::tracing::tracing::proto::SummaryOptions* p = summary_options_;
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.summary_options)
  return p != nullptr ? *p : *reinterpret_cast<const ::catapult::tracing::tracing::proto::SummaryOptions*>(
      &::catapult::tracing::tracing::proto::_SummaryOptions_default_instance_);
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::release_summary_options() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.summary_options)
  
  ::catapult::tracing::tracing::proto::SummaryOptions* temp = summary_options_;
  summary_options_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* Histogram::mutable_summary_options() {
  
  if (summary_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::catapult::tracing::tracing::proto::SummaryOptions>(GetArenaNoVirtual());
    summary_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.summary_options)
  return summary_options_;
}
inline void Histogram::set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* summary_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete summary_options_;
  }
  if (summary_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      summary_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary_options, submessage_arena);
    }
    
  } else {
    
  }
  summary_options_ = summary_options;
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.summary_options)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HistogramSet

// repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
inline int HistogramSet::histograms_size() const {
  return histograms_.size();
}
inline void HistogramSet::clear_histograms() {
  histograms_.Clear();
}
inline ::catapult::tracing::tracing::proto::Histogram* HistogramSet::mutable_histograms(int index) {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >*
HistogramSet::mutable_histograms() {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return &histograms_;
}
inline const ::catapult::tracing::tracing::proto::Histogram& HistogramSet::histograms(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_.Get(index);
}
inline ::catapult::tracing::tracing::proto::Histogram* HistogramSet::add_histograms() {
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram >&
HistogramSet::histograms() const {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return histograms_;
}

// map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
inline int HistogramSet::shared_diagnostics_size() const {
  return shared_diagnostics_.size();
}
inline void HistogramSet::clear_shared_diagnostics() {
  shared_diagnostics_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >&
HistogramSet::shared_diagnostics() const {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return shared_diagnostics_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::catapult::tracing::tracing::proto::Diagnostic >*
HistogramSet::mutable_shared_diagnostics() {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return shared_diagnostics_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::ImprovementDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::catapult::tracing::tracing::proto::Unit> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_histogram_2eproto
